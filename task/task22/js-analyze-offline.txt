# Tool 22 — JS offline analysis (extract endpoints/paths) — STRICT RUN-CARD
# Goal: extract URL/path strings from downloaded JS files (offline, reproducible).
# Input (contract):
#   - temp/agent1/js_fetch_index.txt OR temp/agent1/js_fetch_dir/
# Output (contract):
#   - outputs/js_endpoints_from_js.txt
# Time rule: keep each command under ~9 minutes.

# ----------------------------
# 1) Preconditions
# ----------------------------
#   if (!(Test-Path temp\agent1\js_fetch_index.txt) -and !(Test-Path temp\agent1\js_fetch_dir)) {
#     throw "Missing inputs: expected temp\\agent1\\js_fetch_index.txt or temp\\agent1\\js_fetch_dir"
#   }

# ----------------------------
# 2) Tool
# ----------------------------
# This repo includes a stdlib-only offline analyzer:
#   task\task21\js_analyzer.py

# ----------------------------
# 3) Run (PowerShell)
# ----------------------------
# Preferred (use the index file from Task 21):
#   python task\task21\js_analyzer.py --index temp\agent1\js_fetch_index.txt --out outputs\js_endpoints_from_js.txt
#
# Alternative (scan directory directly):
#   python task\task21\js_analyzer.py --dir temp\agent1\js_fetch_dir --out outputs\js_endpoints_from_js.txt

# ----------------------------
# 3B) Manual analysis workflow (recommended)
# ----------------------------
# Goal: manually review the most important JS first, then use Tool 22 output as a checklist.
#
# 1) Pick "high value" JS quickly
#   - Small files are usually easier to read; large bundles may still contain endpoints.
#   - Look for app bundles (main.*.js, app.*.js, runtime.*.js), config files, or anything under /api/.
#
# If you have the saved JS directory, list largest files:
#   Get-ChildItem -Recurse temp\agent1\js_fetch_dir -File | Sort-Object Length -Descending | Select-Object -First 30 FullName,Length
#
# 2) Open a JS file and search for patterns
#   - "/api" , "graphql" , "swagger" , "openapi" , "token" , "apikey" , "bearer" , "Authorization" , "client_id" , "redirect_uri"
#   - domains and subdomains: "http", "https", "wss", ".com", ".net"
#   - upload paths: "/upload", "/files", "/download"
#
# 3) Compare manual findings with extracted list
#   - The output file is a good "todo list": outputs\js_endpoints_from_js.txt
#   - Later, you can probe interesting absolute URLs with httpx in URL-list mode.

# ----------------------------
# 4) Output sanity check
# ----------------------------
#   if (Test-Path outputs\js_endpoints_from_js.txt) { (Get-Content outputs\js_endpoints_from_js.txt).Count }

# ----------------------------
# 5) Tuning for best output (safe edits)
# ----------------------------
# If output is too noisy or you feel it missed things, you can safely modify:
#   task\task21\js_analyzer.py
#
# Common tweaks:
# - Add/remove keywords in PATH_RE (e.g., add: payments, billing, orders, search, reports)
# - Reduce REL_URL_RE noise by lowering max length (default 200)
# - Ignore common junk paths by adding a skip list (e.g., /static/, /assets/, /images/)
# - Increase max_bytes if your bundles are huge (default 5MB per file)
