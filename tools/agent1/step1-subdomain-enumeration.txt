# Step 1: Subdomain enumeration pipeline
# NOTE: Run ONLY against targets you are explicitly authorized to test (bug bounty scope).

# 1) Install tools
# Go tools (Subfinder, Amass, PureDNS, Alterx, Github-subdomains, Hakrevdns, DNSX)
go install -v github.com/projectdiscovery/subfinder/v2/cmd/subfinder@latest
go install -v github.com/owasp-amass/amass/v4/...@latest
go install -v github.com/d3mondev/puredns/v2/cmd/puredns@latest
go install -v github.com/projectdiscovery/alterx/cmd/alterx@latest
go install -v github.com/gwen001/github-subdomains@latest
go install -v github.com/hakluke/hakrevdns@latest
go install -v github.com/projectdiscovery/dnsx/cmd/dnsx@latest

# Python tool
pip install waymore

# 2) Prerequisites you must provide
# - A resolver list for DNS validation (recommended: 50-200 resolvers)
#   Save to: temp/agent1/resolvers.txt
# - A large brute-force wordlist for subdomain guessing
#   Save to: temp/agent1/subdomain_wordlist.txt
# - (Optional) Company IP ranges for reverse DNS (only if in scope)

# External files (download + place)
# 1) DNS resolvers list (required)
# - Recommended source (maintained):
#   https://github.com/trickest/resolvers
#   Direct link (example):
#   https://raw.githubusercontent.com/trickest/resolvers/main/resolvers.txt
# - Save as: temp/agent1/resolvers.txt
#
# 2) Subdomain bruteforce wordlist (required for PureDNS bruteforce)
# - Recommended source: SecLists
#   https://github.com/danielmiessler/SecLists
# - Good starter list (example path inside SecLists):
#   Discovery/DNS/subdomains-top1million-5000.txt
# - Larger options exist; choose based on scope/time (more coverage = more noise/time):
#   - Discovery/DNS/subdomains-top1million-110000.txt
#   - Discovery/DNS/dns-Jhaddix.txt (very large; use carefully)
# - Optional additional source (high-signal curated):
#   https://github.com/assetnote/commonspeak2-wordlists
# - Best practice: start small, then scale.
#
# Wordlist strategy (recommended):
# - Start with ONE small list for quick wins.
# - If results look thin, combine 2-3 lists into ONE file and point PureDNS to that:
#   Save the combined list as: temp/agent1/subdomain_wordlist.txt
# - Save as: temp/agent1/subdomain_wordlist.txt

# Create folders (if not already present)
# - temp/agent1
# - outputs

# File contract (Step 1)
# Input:
# - Root domain (single target), e.g. example.com
# - temp/agent1/resolvers.txt
# - temp/agent1/subdomain_wordlist.txt
# - (Optional) in-scope IP ranges for reverse DNS
#
# Intermediates written to temp/agent1/:
# - list_1_passive.txt
# - list_2_archives.txt
# - list_3_bruteforce.txt
# - list_4_reverse.txt
# - list_5_permutations.txt
# - candidates_all.txt (merged + deduped candidates)
# - resolved.txt (post-validation)
#
# Final output written to outputs/:
# - activesubdomain.txt (unique, DNS-resolving, wildcard-filtered)
# - reports/agent1-recon-report.md (running report / decisions)

Run logic (single target root domain as input)

Input:
- target root domain (example.com)

Outputs:
- outputs/activesubdomain.txt  (final: unique + DNS-resolving subdomains only)
- temp/agent1/*               (all intermediate lists)

Steps:

1) Passive discovery
- subfinder + amass + github-subdomains
- Save combined (deduped) to: temp/agent1/list_1_passive.txt

2) Archives discovery
- waymore on the root domain
- Save to: temp/agent1/list_2_archives.txt

3) Bruteforce discovery
- puredns bruteforce with a big wordlist
- IMPORTANT: bruteforce results are noisy until validated
- Save to: temp/agent1/list_3_bruteforce.txt

4) Reverse DNS (only if IP ranges are explicitly in scope)
- hakrevdns on the in-scope IP ranges
- Save to: temp/agent1/list_4_reverse.txt

5) Permutations
- Combine lists 1-4, remove duplicates, then run alterx
- Save to: temp/agent1/list_5_permutations.txt

6) Final validation (must remove wildcard DNS noise)
- Combine ALL candidates (lists 1-5), dedupe
- Validate with one of these:
	- puredns resolve (recommended because it can do wildcard tests)
	- dnsx (fast resolver) + separate wildcard filtering strategy

Recommended output flow (keep the file contract consistent):
- Write merged/deduped candidates to: temp/agent1/candidates_all.txt
- Write validated resolves to: temp/agent1/resolved.txt
- Write final wildcard-filtered list to: outputs/activesubdomain.txt

Brain Stop #1 (Mandatory): Step 1 Quality Gate
Instruction to Jules:
- STOP running tools.
- Open outputs/activesubdomain.txt and verify:
	- Is NOT empty (if empty, STOP and re-check inputs/resolvers/wildcard filtering)
	- Includes the root/apex domain if it resolves (example.com)
	- No duplicates
	- No obvious wildcard noise
	- Looks in-scope (no unrelated domains)
- Write a short Step 1 summary into: outputs/reports/agent1-recon-report.md
	Include: target, counts (candidates vs resolved), wildcard notes, and any scope constraints.
- If quality is bad, re-run validation with tighter wildcard filtering and resolvers.
- Only after this gate passes, start Step 2.

Final output requirements:
- outputs/activesubdomain.txt must contain NO duplicates
- outputs/activesubdomain.txt must contain ONLY DNS-resolving ("live") subdomains
- If you detect wildcard DNS, filter wildcard results (do not blindly trust bruteforce/permutations)

Note about the root/apex domain:
- Include the original target root domain (example.com) in outputs/activesubdomain.txt IF it resolves in DNS.
- This helps downstream URL discovery (step 2) because many programs host content on the apex.