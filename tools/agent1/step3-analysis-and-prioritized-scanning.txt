# Step 3: Analysis + Prioritized Scanning (Deep Work)
# NOTE: Run ONLY against targets you are explicitly authorized to test (bug bounty scope).

Purpose:
- Convert Step 2’s collected corpus/artifacts into a prioritized testing queue.
- Run the heavier tools ONLY on the best candidates (experienced-hacker behavior).

Prereqs / Installs (for Step 3)

Tools used in Step 3:
- httpx (fetch JS files for offline analysis)
- JSluice, XnLinkFinder (JS analysis)
- ffuf (targeted fuzzing on top candidates)
- kiterunner (kr) (API route discovery)
- arjun (hidden parameter discovery)

Installation notes:
- If you already installed tools during Step 2, you can reuse them.
- Install commands (typical):
	- Go: httpx, ffuf, kiterunner, jsluice
	- Python: pip install arjun
	- XnLinkFinder: cloned under tools/ and installed via requirements.txt (if used)

External files required:
1) FFUF content wordlist
- Source: SecLists https://github.com/danielmiessler/SecLists
- Pick ONE and save as: temp/agent1/content_wordlist.txt
	- Discovery/Web-Content/raft-small-directories.txt
	- Discovery/Web-Content/raft-medium-directories.txt
	- Discovery/Web-Content/common.txt

2) Kiterunner routes wordlist
- Download and extract ONE .kite file:
	- routes-small: https://wordlists-cdn.assetnote.io/data/kiterunner/routes-small.kite.tar.gz
	- routes-large: https://wordlists-cdn.assetnote.io/data/kiterunner/routes-large.kite.tar.gz
- Save extracted file as: temp/agent1/routes.kite

3) Optional GitHub token
- If you plan to run GitDorker (Step 2/Step 3 context), set GITHUB_TOKEN (redact in reports).

Inputs (from previous steps)
- outputs/activesubdomain.txt (host allowlist from Step 1)
- temp/agent1/url_corpus_all_in_scope.txt (merged normalized URL corpus from Step 2)
- temp/agent1/host_fingerprints.txt (from Step 2)
- temp/agent1/waf_results.txt (from Step 2)
- outputs/api_docs_urls.txt (from Step 2)
- outputs/api_endpoints_from_openapi.txt (from Step 2)

Outputs (write to outputs/)
- outputs/queue_dynamic_endpoints_urls.txt
- outputs/queue_login_panels_urls.txt
- outputs/queue_sensitive_files_urls.txt
- outputs/queue_cloud_bucket_urls.txt
- outputs/queue_static_assets_urls.txt
- outputs/queue_api_endpoints_kiterunner.txt
- outputs/queue_hidden_params_arjun.txt
- outputs/reports/agent1-recon-report.md (append analysis/decisions)
- outputs/reports/agent1-error-report.md (tool failures/skips)

Intermediates (write to temp/agent1/)
- priority_hosts.txt
- api_priority_hosts.txt
- js_files.txt
- js_responses/
- response_manifest.txt (optional)
- kiterunner_raw.txt
- hidden_params_raw.txt

Artifact retention (Mandatory)
- Do NOT delete temp/agent1/ after Step 3.
- If disk space is an issue, compress/archive temp/agent1/ instead of removing it.

Error / Skip Reporting (Mandatory)
- Use outputs/reports/agent1-error-report.md with the template from Step 2.
- Record: command, error text, reason, impact, mitigation.

0) Pre-checks (Mandatory)
- Verify temp/agent1/url_corpus_all_in_scope.txt exists and is non-empty.
- Verify scope allowlist exists (outputs/activesubdomain.txt).
- If allowlist is empty: STOP and fix Step 1.

1) Build the Top Candidate Host Lists (Mandatory)
Goal:
- Select a small set of hosts to scan deeply instead of hammering everything.

Create:
1) temp/agent1/priority_hosts.txt
- Include hosts that match ANY of these signals:
	- Has API docs (host appears in outputs/api_docs_urls.txt)
	- Has extracted API endpoints (host appears in outputs/api_endpoints_from_openapi.txt)
	- Looks like a real app in temp/agent1/host_fingerprints.txt (not parked/placeholder)
	- Returns 401/403 on interesting paths (still "live")
	- Hostname suggests sensitive surfaces: api., admin., portal., support., auth., sso., internal.

2) temp/agent1/api_priority_hosts.txt
- Subset of priority_hosts that are likely API gateways/services:
	- host starts with api./gateway.
	- OR has Swagger/OpenAPI hits
	- OR has many /api, /v1, /v2 paths observed

WAF-aware rule:
- If a host is marked as "detected" or "inconclusive" in temp/agent1/waf_results.txt:
	- You MAY scan it, but only with conservative rates.

Brain Stop (Mandatory): Candidate justification
- Append to outputs/reports/agent1-recon-report.md:
	- Your top 5–15 hosts and why they were selected
	- Which hosts are WAF-protected / inconclusive

2) Categorize URLs into Buckets (Mandatory)
Goal:
- Create practical testing queues.

Instruction:
- From temp/agent1/url_corpus_all_in_scope.txt (and outputs/api_endpoints_from_openapi.txt), generate these 5 buckets:

queue_dynamic_endpoints_urls.txt -> High Priority
- URLs with parameters (?id=)
- Dynamic endpoints (.php, .jsp, .aspx, .do, .action)
- API paths (/api, /v1, /v2)

queue_login_panels_urls.txt -> High Priority
- URLs containing: admin, login, signin, sso, oauth, saml, dashboard

queue_cloud_bucket_urls.txt -> Medium Priority
- URLs pointing to likely buckets: s3, storage, blob, gcs (in-scope only)

queue_sensitive_files_urls.txt -> Critical Priority
- .env, .json (interesting configs), .yml/.yaml, .xml, .log, backups

queue_static_assets_urls.txt -> Low Priority / Ignore
- images, fonts, css; keep for reference but don’t fuzz aggressively

Brain Stop (Mandatory): Bucket sanity
- If endpoints/login/sensitive are near-empty, revisit Step 2 collection quality.
- Append bucket counts to outputs/reports/agent1-recon-report.md.

3) Deep JS Analysis + Offline JS Capture (Recommended)
Goal:
- Extract endpoints/secrets from JS with repeatability.

Instruction:
- Build temp/agent1/js_files.txt from temp/agent1/url_corpus_all_in_scope.txt (only in-scope, only URLs ending with .js).
- Fetch and store JS files for offline analysis:
	- Save to: temp/agent1/js_responses/
- Run JS analysis tools (choose based on availability):
	- JSluice (structure-based)
	- XnLinkFinder (regex-based)

Record:
- Any newly discovered endpoints should be merged back into temp/agent1/url_corpus_all_in_scope.txt (normalize/dedupe) and re-bucket if needed.

4) Ffuf on Top Candidates (Recommended)
Goal:
- Discover unlinked directories/files but only on high-signal hosts.

Instruction:
- Run ffuf ONLY against temp/agent1/priority_hosts.txt.
- Start with targeted basepaths derived from API docs/robots/sitemaps.

Troubleshooting:
- If results are mostly 301/302, verify scheme/host and filter redirect codes.

5) Kiterunner on API Priority Hosts (Recommended)
Goal:
- Discover method-specific API routes that crawling misses.

Instruction:
- Run kr primarily against temp/agent1/api_priority_hosts.txt.
- Save raw output to temp/agent1/kiterunner_raw.txt.
- Extract endpoints to outputs/queue_api_endpoints_kiterunner.txt.

Note:
- "No results" can be a valid outcome.

6) Hidden Parameter Discovery (Arjun) (Recommended)
Goal:
- Find hidden GET params on high-value endpoints.

Instruction:
- Run Arjun ONLY on outputs/queue_dynamic_endpoints_urls.txt (or a smaller high-value subset).
- Save raw output to temp/agent1/hidden_params_raw.txt.
- Write clean list to outputs/queue_hidden_params_arjun.txt.

Final Brain Stop (Mandatory): Testing Queue Preparation
- Review:
	- outputs/queue_dynamic_endpoints_urls.txt
	- outputs/queue_login_panels_urls.txt
	- outputs/queue_sensitive_files_urls.txt
	- outputs/api_docs_urls.txt
	- outputs/api_endpoints_from_openapi.txt
	- outputs/queue_api_endpoints_kiterunner.txt
	- outputs/queue_hidden_params_arjun.txt
- Write a final “what to test first and why” plan into outputs/reports/agent1-recon-report.md.
